<ServerManagerConfiguration>
  <ProxyGroup name="internal_filters">
   <!-- ==================================================================== -->
   <SourceProxy name="AppendArcLength" class="vtkAppendArcLength"
      label="Append Arc-Length" >
      <Documentation
        short_help="Appends Arc length for input poly lines."
        long_help="Appends Arc length for input poly lines." >
        Internal filter used by (filters, ProbeLine).

        vtkAppendArcLength is used for filter such as plot-over-line. In such
        cases, we need to add an attribute array that is the arc_length over the
        length of the probed line. That's when vtkAppendArcLength can be used.
        It adds a new point-data array named "arc_length" with the computed arc
        length for each of the polylines in the input. For all other cell types,
        the arc length is set to 0.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>
          The input.
        </Documentation>
      </InputProperty>
      <!-- End of AppendArcLength -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ProbeLine" class="vtkPProbeFilter" >
      <Documentation>
        Internal filter used by (filters, ProbeLine).

        The Plot Over Line filter samples the data set attributes of the current
        data set at the points along a line. The values of the point-centered variables
        along that line will be displayed in an XY Plot. This filter uses interpolation
        to determine the values at the selected point, whether or not it lies at an
        input point. The Probe filter operates on any type of data and produces
        polygonal output (a line).
      </Documentation>
      <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkCompositeDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection"
        label="Probe Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="extended_sources" name="HighResLineSource" />
           </ProxyListDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>

      <IntVectorProperty name="PassPartialArrays"
        command="SetPassPartialArrays"
        number_of_elements="1"
        default_values="1">
        <Documentation>
          When dealing with composite datasets, partial arrays are common i.e.
          data-arrays that are not available in all of the blocks. By default,
          this filter only passes those point and cell data-arrays that are
          available in all the blocks i.e. partial array are removed.  When
          PassPartialArrays is turned on, this behavior is changed to take a
          union of all arrays present thus partial arrays are passed as well.
          However, for composite dataset input, this filter still produces a
          non-composite output. For all those locations in a block of where a
          particular data array is missing, this filter uses vtkMath::Nan() for
          double and float arrays, while 0 for all other types of arrays i.e
          int, char etc.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

   <!-- End ProbeLine -->
   </SourceProxy>

    <!-- End of internal_filters -->
  </ProxyGroup>


  <ProxyGroup name="filters">

    <!-- ==================================================================== -->
   <SourceProxy name="ExtractSelectionOverTime" class="vtkPExtractArraysOverTime"
      label="Plot Selection Over Time">
      <Documentation
        short_help="Extracts selection over time and then plots it."
        long_help="Extracts selection over time and then plots it." >
        This filter extracts the selection over time, i.e.  cell and/or point
        variables at a cells/point selected are extracted over time
        The output multi-block consists of 1D rectilinear grids where the x coordinate
        corresponds to time (the same array is also copied to a point array named
        Time or TimeData (if Time exists in the input)).
        If selection input is a Location based selection then the point values are
        interpolated from the nearby cells, ie those of the cell the location
        lies in.
     </Documentation>

     <InputProperty name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkCompositeDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <InputProperty name="Selection"
         command="SetSelectionConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkSelection"/>
       </DataTypeDomain>
       <Documentation>
         The input that provides the selection object.
       </Documentation>
       <Hints>
         <!-- This tag alerts the auto-generated panels and input selection
              that this input is a selection.  It should use the special
              selection GUI. -->
         <SelectionInput />
       </Hints>
     </InputProperty>

     <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />

        <!-- Temporary hint to allow the output of this filter to be plotted -->
        <Plotable />
     </Hints>
     <!-- End of ExtractSelectionOverTime -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractFieldDataOverTime"
                          class="vtkExtractTemporalFieldData"
                          label="Plot Global Variables Over Time">
     <Documentation
      short_help="Extracts and plots data in field data over time."
      long_help="Extracts and plots data in field data over time." >
This filter extracts the variables that reside in a dataset's field data and are
defined over time. The output is a 1D rectilinear grid where the x coordinates
correspond to time (the same array is also copied to a point array named Time or
TimeData (if Time exists in the input)).
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
     </Hints>

     <!-- End ExtractFieldDatasOverTime -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ImageShrink" class="vtkImageShrink3D" label="Image Shrink">
    <Documentation
      short_help="Subsample an image/volume."
      long_help="Reduce the size of an image/volume by subsampling.">
      The Image Shrink filter reduces the size of an image/volume dataset by subsampling it (i.e., extracting every nth pixel/voxel in integer multiples). The sbsampling rate can be set separately for each dimension of the image/volume.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Image Shrink filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="ShrinkFactors"
        command="SetShrinkFactors"
        number_of_elements="3"
        animateable="1"
        default_values="1 1 1" >
       <IntRangeDomain name="range" min="1" max="100"/>
       <Documentation>
         The value of this property indicates the amount by which to shrink along each axis.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Averaging"
        command="SetAveraging"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, an average of neighborhood scalar values will be used as the output scalar value for each output point. If its value is 0, only subsampling will be performed, and the original scalar values at the points will be retained.
       </Documentation>
     </IntVectorProperty>
     <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
     </Hints>
   <!-- End ImageShrink -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="SurfaceVectors" class="vtkSurfaceVectors" label="Surface Vectors">
     <Documentation
          long_help="This filter constrains vectors to lie on a surface."
          short_help="This filter constrains vectors to lie on a surface.">
The Surface Vectors filter is used for 2D data sets. It constrains vectors to lie in a surface by removing components of the vectors normal to the local surface.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Surface Vectors filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputVectors"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              This property specifies the name of the input vector array to process.
            </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="ConstraintMode"
        command="SetConstraintMode"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Parallel"/>
         <Entry value="1" text="Perpendicular"/>
         <Entry value="2" text="PerpendicularScale"/>
       </EnumerationDomain>
       <Documentation>
         This property specifies whether the vectors will be parallel or perpendicular to the surface. If the value is set to PerpendicularScale (2), then the output will contain a scalar array with the dot product of the surface normal and the vector at each point.
       </Documentation>
     </IntVectorProperty>

   <!-- End SurfaceVectors -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="IntegrateAttributes" class="vtkIntegrateAttributes"
     label="Integrate Variables">
     <Documentation
        long_help="This filter integrates cell and point attributes."
        short_help="Integrates over lines, surfaces or vectors.">
The Integrate Attributes filter integrates point and cell data over lines and surfaces.  It also computes length of lines, area of surface, or volume.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Integrate Attributes filter.
           </Documentation>
      </InputProperty>
   <Hints>
     <Visibility replace_input="0" />
     <!-- View can be used to specify the preferred view for the proxy -->
     <View type="SpreadSheetView" />
     <Plotable />
   </Hints>
   <!-- End IntegrateAttributes -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="IntegrateFlowThroughSurface" class="vtkIntegrateFlowThroughSurface" label="Surface Flow">
     <Documentation
        long_help="This filter integrates flow through a surface."
        short_help="This filter integrates flow through a surface.">
The flow integration fitler  integrates the dot product of a point flow vector field and surface normal. It computes the net flow across the 2D surface. It operates on any type of dataset and produces an unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Surface Flow filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty
         name="SelectInputVectors"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              The value of this property specifies the name of the input vector array containing the flow vector field.
            </Documentation>
      </StringVectorProperty>

   <!-- End IntegrateFlowThroughSurface -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="AllToN" class="vtkAllToNRedistributePolyData"
                label="All to N"
                multiprocess_support="multiple_processes">
      <Documentation
         long_help="Redistribute data to a subset of available processes."
         short_help="Repartition data filter.">
The All to N filter is available when ParaView is run in parallel. It redistributes the data so that it is located on the number of processes specified in the Number of Processes entry box. It also does load-balancing of the data among these processes. This filter operates on polygonal data and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the All to N filter.
           </Documentation>
      </InputProperty>

      <IntVectorProperty
         name="NumberOfProcesses"
         command="SetNumberOfProcesses"
         number_of_elements="1"
         default_values="1"
         label="Number of Processes">
         <Documentation>
           Set the number of processes across which to split the input data.
         </Documentation>
      </IntVectorProperty>
   <!-- End AllToN -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Balance" class="vtkBalancedRedistributePolyData"
                multiprocess_support="multiple_processes">
      <Documentation
         long_help="Balance data among available processes."
         short_help="Load balance filter.">
The Balance filter is available when ParaView is run in parallel. It does load-balancing so that all processes have the same number of cells. It operates on polygonal data sets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Balance filter.
           </Documentation>
      </InputProperty>
   <!-- End Balance -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="AppendAttributes" class="vtkMergeArrays"
    label="Append Attributes">
      <Documentation
         long_help="Copies geometry from first input.  Puts all of the arrays into the output."
         short_help="Puts all input arrays into the single output.">
The Append Attributes filter takes multiple input data sets with the same geometry and merges their point and cell attributes to produce a single output containing all the point and cell attributes of the inputs. Any inputs without the same number of points and cells as the first input are ignored. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Append Attributes filter.
           </Documentation>
      </InputProperty>

   <!-- End AppendAttributes -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="AppendPolyData" class="vtkAppendPolyData"
      label="Append Geometry">
      <Documentation
         long_help="Takes an input of multiple poly data parts and output has only one part."
         short_help="Append multiple parts into one.">
The Append Geometry filter operates on multiple polygonal data sets. It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Append Geometry filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendPolyData -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Append" class="vtkAppendFilter" label="Append Datasets">
      <Documentation
         long_help="Takes an input of multiple datasets and output has only one unstructured grid."
         short_help="Append multiple datasets into one.">
The Append Datasets filter operates on multiple data sets of any type (polygonal, structured, etc.). It merges their geometry into a single data set. Only the point and cell attributes that all of the input data sets have in common will appear in the output. The input data sets must already be collected together, either as a result of a reader that loads multiple parts (e.g., EnSight reader) or because the Group Parts filter has been run to form a collection of data sets.
      </Documentation>
      <InputProperty
         name="Input"
         command="AddInputConnection"
         clean_command="RemoveAllInputs"
         multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="0">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the datasets to be merged into a single dataset by the Append Datasets filter.
           </Documentation>
      </InputProperty>
   <!-- End AppendDataSet -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CellCenters" class="vtkCellCenters" label="Cell Centers">
     <Documentation
        long_help="Create a point (no geometry) at the center of each input cell."
        short_help="Convert cells to vertices.">
The Cell Centers filter places a point at the center of each cell in the input data set. The center computed is the parametric center of the cell, not necessarily the geometric or bounding box center. The cell attributes of the input will be associated with these newly created points of the output. You have the option of creating a vertex cell per point in the outpuut. This is useful because vertex cells are rendered, but points are not. The points themselves could be used for placing glyphs (using the Glyph filter). The Cell Centers filter takes any type of data set as input and produces a polygonal data set as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Cell Centers filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="VertexCells"
        command="SetVertexCells"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If set to 1, a vertex cell will be generated per point in the output. Otherwise only points will be generated.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellCenters -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CellDataToPointData" class="vtkPCellDataToPointData"
     label="Cell Data to Point Data">
     <Documentation
        long_help="Create point attributes by averaging cell attributes."
        short_help="Convert cell data to point data.">
The Cell Data to Point Data filter averages the values of the cell attributes of the cells surrounding a point to compute point attributes. The Cell Data to Point Data filter operates on any type of data set, and the output data set is of the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell"/>
          <Documentation>
            This property specifies the input to the Cell Data to Point Data filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="PassCellData"
        command="SetPassCellData"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then the input cell data is passed through to the output; otherwise, only the generated point data will be available in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="PieceInvariant"
        command="SetPieceInvariant"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, this filter will request ghost levels so that the values at boundary points match across processes. NOTE: Enabling this option might cause multiple executions of the data source because more information is needed to remove internal surfaces.
       </Documentation>
     </IntVectorProperty>

   <!-- End CellDataToPointData -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="GenerateIdScalars" class="vtkIdFilter"
     label="Generate Ids">
     <Documentation
        long_help="Generate scalars from point and cell ids."
        short_help="Generate scalars from point and cell ids.">
This filter generates scalars  using cell and point ids. That is, the point attribute data scalars are generated from the point ids, and the cell attribute data scalars or field data are generated from the the cell ids.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Cell Data to Point Data filter.
          </Documentation>
     </InputProperty>
     <StringVectorProperty
        name="ArrayName"
        command="SetIdsArrayName"
        number_of_elements="1"
        default_values="Ids">
        <Documentation>
          The name of the array that will contain ids.
        </Documentation>
     </StringVectorProperty>

   <!-- End GenerateIdScalars -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CleanPolyData" class="vtkCleanPolyData"
     label="Clean">
     <Documentation
        long_help="Merge coincident points if they do not meet a feature edge criteria."
        short_help="Merge coincident points.">
The Clean filter takes polygonal data as input and generates polygonal data as output. This filter can merge duplicate points, remove unused points, and transform degenerate cells into their appropriate forms (e.g., a triangle is converted into a line if two of its points are merged).
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Clean filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="PieceInvariant"
        command="SetPieceInvariant"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the whole data set will be processed at once so that cleaning the data set always produces the same results. If it is set to 0, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory; however the results are not guaranteed to be the same as they would be if the Piece invariant option was on. Setting this option to 0 may produce seams in the output dataset when ParaView is run in parallel.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         If merging nearby points (see PointMerging property) and not using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging as a fraction of the length of the diagonal of the bounding box of the input data set.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="AbsoluteTolerance"
        command="SetAbsoluteTolerance"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         If merging nearby points (see PointMerging property) and using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging in the spatial units of the input data set.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="ToleranceIsAbsolute"
        command="SetToleranceIsAbsolute"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This property determines whether to use absolute or relative (a percentage of the bounding box) tolerance when performing point merging.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ConvertLinesToPoints"
        command="SetConvertLinesToPoints"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate lines (a "line" whose endpoints are at the same spatial location) will be converted to points.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ConvertPolysToLines"
        command="SetConvertPolysToLines"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate polygons (a "polygon" with only two distinct point coordinates) will be converted to lines.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ConvertStripsToPolys"
        command="SetConvertStripsToPolys"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, degenerate triangle strips (a triangle "strip" containing only one triangle) will be converted to triangles.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="PointMerging"
        command="SetPointMerging"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then points will be merged if they are within the specified Tolerance or AbsoluteTolerance (see the Tolerance and AbsoluteTolerance propertys), depending on the value of the ToleranceIsAbsolute property. (See the ToleranceIsAbsolute property.) If this property is set to 0, points will not be merged.
       </Documentation>
     </IntVectorProperty>
   <!-- End CleanPolyData -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CleanUnstructuredGrid" class="vtkCleanUnstructuredGrid"
      label="Clean to Grid">
      <Documentation
         long_help="This filter merges points and converts the data set to unstructured grid."
         short_help="Merge points.">
The Clean to Grid filter merges points that are exactly coincident. It also converts the data set to an unstructured grid. You may wish to do this if you want to apply a filter to your data set that is available for unstructured grids but not for the initial type of your data set (e.g., applying warp vector to volumetric data). The Clean to Grid filter operates on any type of data set.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Clean to Grid filter.
           </Documentation>
      </InputProperty>
   <!-- End CleanUnstructuredGrid -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CleanUnstructuredGridCells" class="vtkCleanUnstructuredGridCells"
      label="Clean Cells to Grid">
      <Documentation
         long_help="This filter merges cells and converts the data set to unstructured grid."
         short_help="Merge cells.">
Merges degenerate cells. Assumes the input grid does not contain duplicate
points. You may want to run vtkCleanUnstructuredGrid first to assert it. If
duplicated cells are found they are removed in the output. The filter also
handles the case, where a cell may contain degenerate nodes (i.e. one and
the same node is referenced by a cell more than once).
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkUnstructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Clean Cells to Grid filter.
           </Documentation>
      </InputProperty>
   <!-- End CleanUnstructuredGridCells -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Delaunay2D" class="vtkDelaunay2D" label="Delaunay 2D">
      <Documentation
         long_help="Create 2D Delaunay triangulation of input points.
It expects a vtkPointSet as input and produces vtkPolyData as output.
The points are expected to be in a mostly planar distribution."
         short_help="Create 2D Delaunay triangulation of input points.">
Delaunay2D is a filter that constructs a 2D Delaunay triangulation from a list of input points. These points may be represented by any dataset of type vtkPointSet and subclasses. The output of the filter is a polygonal dataset containing a triangle mesh.

The 2D Delaunay triangulation is defined as the triangulation that satisfies the Delaunay criterion for n-dimensional simplexes (in this case n=2 and the simplexes are triangles). This criterion states that a circumsphere of each simplex in a triangulation contains only the n+1 defining points of the simplex. In two dimensions, this translates into an optimal triangulation. That is, the maximum interior angle of any triangle is less than or equal to that of any possible triangulation.

Delaunay triangulations are used to build topological structures from unorganized (or unstructured) points. The input to this filter is a list of points specified in 3D, even though the triangulation is 2D. Thus the triangulation is constructed in the x-y plane, and the z coordinate is ignored (although carried through to the output). You can use the option ProjectionPlaneMode in order to compute the best-fitting plane to the set of points, project the points and that plane and then perform the triangulation using their projected positions and then use it as the plane in which the triangulation is performed.

The Delaunay triangulation can be numerically sensitive in some cases. To prevent problems, try to avoid injecting points that will result in triangles with bad aspect ratios (1000:1 or greater). In practice this means inserting points that are "widely dispersed", and enables smooth transition of triangle sizes throughout the mesh. (You may even want to add extra points to create a better point distribution.) If numerical problems are present, you will see a warning message to this effect at the end of the triangulation process.

Warning:
Points arranged on a regular lattice (termed degenerate cases) can be triangulated in more than one way (at least according to the Delaunay criterion). The choice of triangulation (as implemented by this algorithm) depends on the order of the input points. The first three points will form a triangle; other degenerate points will not break this triangle.

Points that are coincident (or nearly so) may be discarded by the algorithm. This is because the Delaunay triangulation requires unique input points. The output of the Delaunay triangulation is supposedly a convex hull. In certain cases this implementation may not generate the convex hull.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input dataset to the Delaunay 2D filter.
           </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="ProjectionPlaneMode"
        command="SetProjectionPlaneMode"
        number_of_elements="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="0" text="XY Plane"/>
<!--         <Entry value="1" text="Perpendicular"/> -->
         <Entry value="2" text="Best-Fitting Plane"/>
       </EnumerationDomain>
       <Documentation>
         This property determines type of projection plane to use in performing the triangulation.
       </Documentation>
     </IntVectorProperty>
     <DoubleVectorProperty name="Alpha"
       command="SetAlpha"
       number_of_elements="1"
       animateable="1"
       default_values="0.0">
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property controls the output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Tolerance"
       command="SetTolerance"
       number_of_elements="1"
       animateable="1"
       default_values="0.00001">
       <DoubleRangeDomain name="range" min="0" max="1.0" />
       <Documentation>
         This property specifies a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.
       </Documentation>
     </DoubleVectorProperty>
     <DoubleVectorProperty name="Offset"
       command="SetOffset"
       number_of_elements="1"
       animateable="1"
       default_values="1.0">
       <DoubleRangeDomain name="range" min="0.75"/>
       <Documentation>
         This property is a multiplier to control the size of the initial, bounding Delaunay triangulation.
       </Documentation>
     </DoubleVectorProperty>
     <IntVectorProperty name="BoundingTriangulation"
       command="SetBoundingTriangulation"
       number_of_elements="1"
       animateable="1"
       default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, bounding triangulation points (and associated triangles) are included in the output. These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.
       </Documentation>
     </IntVectorProperty>
     <!-- End Delaunay2D -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Delaunay3D" class="vtkDelaunay3D" label="Delaunay 3D">
     <Documentation short_help="Create a 3D Delaunay triangulation of input
                                points."
                    long_help="Create a 3D Delaunay triangulation of input
                               points.  It expects a vtkPointSet as input and
                               produces vtkUnstructuredGrid as output.">

       Delaunay3D is a filter that constructs a 3D Delaunay triangulation
       from a list of input points. These points may be represented by any
       dataset of type vtkPointSet and subclasses. The output of the filter
       is an unstructured grid dataset. Usually the output is a tetrahedral
       mesh, but if a non-zero alpha distance value is specified (called
       the "alpha" value), then only tetrahedra, triangles, edges, and
       vertices lying within the alpha radius are output. In other words,
       non-zero alpha values may result in arbitrary combinations of
       tetrahedra, triangles, lines, and vertices. (The notion of alpha
       value is derived from Edelsbrunner's work on "alpha shapes".)

       The 3D Delaunay triangulation is defined as the triangulation that
       satisfies the Delaunay criterion for n-dimensional simplexes (in
       this case n=3 and the simplexes are tetrahedra). This criterion
       states that a circumsphere of each simplex in a triangulation
       contains only the n+1 defining points of the simplex. (See text for
       more information.) While in two dimensions this translates into an
       "optimal" triangulation, this is not true in 3D, since a measurement
       for optimality in 3D is not agreed on.

       Delaunay triangulations are used to build topological structures
       from unorganized (or unstructured) points. The input to this filter
       is a list of points specified in 3D. (If you wish to create 2D
       triangulations see Delaunay2D.) The output is an unstructured
       grid.

       The Delaunay triangulation can be numerically sensitive. To prevent
       problems, try to avoid injecting points that will result in
       triangles with bad aspect ratios (1000:1 or greater). In practice
       this means inserting points that are "widely dispersed", and enables
       smooth transition of triangle sizes throughout the mesh. (You may
       even want to add extra points to create a better point
       distribution.) If numerical problems are present, you will see a
       warning message to this effect at the end of the triangulation
       process.

       Warning:
       Points arranged on a regular lattice (termed degenerate cases) can
       be triangulated in more than one way (at least according to the
       Delaunay criterion). The choice of triangulation (as implemented by
       this algorithm) depends on the order of the input points. The first
       four points will form a tetrahedron; other degenerate points
       (relative to this initial tetrahedron) will not break it.

       Points that are coincident (or nearly so) may be discarded by the
       algorithm. This is because the Delaunay triangulation requires
       unique input points. You can control the definition of coincidence
       with the "Tolerance" instance variable.

       The output of the Delaunay triangulation is supposedly a convex
       hull. In certain cases this implementation may not generate the
       convex hull. This behavior can be controlled by the Offset instance
       variable. Offset is a multiplier used to control the size of the
       initial triangulation. The larger the offset value, the more likely
       you will generate a convex hull; and the more likely you are to see
       numerical problems.

       The implementation of this algorithm varies from the 2D Delaunay
       algorithm (i.e., Delaunay2D) in an important way. When points are
       injected into the triangulation, the search for the enclosing
       tetrahedron is quite different. In the 3D case, the closest
       previously inserted point point is found, and then the connected
       tetrahedra are searched to find the containing one. (In 2D, a "walk"
       towards the enclosing triangle is performed.) If the triangulation
       is Delaunay, then an enclosing tetrahedron will be found. However,
       in degenerate cases an enclosing tetrahedron may not be found and
       the point will be rejected.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters" />
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet" />
       </DataTypeDomain>
       <Documentation>
         This property specifies the input dataset to the Delaunay 3D filter.
       </Documentation>
     </InputProperty>

     <DoubleVectorProperty name="Alpha"
                           command="SetAlpha"
                           number_of_elements="1"
                           animateable="1"
                           default_values="0.0">
       <DoubleRangeDomain name="range" min="0" />
       <Documentation>
         This property specifies the alpha (or distance) value to control
         the output of this filter.  For a non-zero alpha value, only
         edges, faces, or tetra contained within the circumsphere (of
         radius alpha) will be output.  Otherwise, only tetrahedra will be
         output.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty name="Tolerance"
                           command="SetTolerance"
                           number_of_elements="1"
                           animateable="1"
                           default_values="0.001">
       <DoubleRangeDomain name="range" min="0" max="1.0" />
       <Documentation>
         This property specifies a tolerance to control discarding of
         closely spaced points. This tolerance is specified as a fraction
         of the diagonal length of the bounding box of the points.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty name="Offset"
                           command="SetOffset"
                           number_of_elements="1"
                           animateable="1"
                           default_values="2.5">
       <DoubleRangeDomain name="range" min="2.5" />
       <Documentation>
         This property specifies a multiplier to control the size of the
         initial, bounding Delaunay triangulation.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty name="BoundingTriangulation"
                        command="SetBoundingTriangulation"
                        number_of_elements="1"
                        animateable="1"
                        default_values="0">
       <BooleanDomain name="bool" />
       <Documentation>
         This boolean controls whether bounding triangulation points (and
         associated triangles) are included in the output. (These are
         introduced as an initial triangulation to begin the triangulation
         process. This feature is nice for debugging output.)
       </Documentation>
     </IntVectorProperty>

     <!-- End Delaunay3d -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PVConnectivityFilter" class="vtkConnectivityFilter"
      label="Connectivity">
      <Documentation
          long_help="Mark connected components with integer point attribute array."
          short_help="Find connected components.">
The Connectivity filter assigns a region id to connected components of the input data set. (The region id is assigned as a point scalar value.) This filter takes any data set type as input and produces unstructured grid output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Connectivity filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="ExtractionMode"
        command="SetExtractionMode"
        number_of_elements="1"
        default_values="5" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="Extract Point Seeded Regions"/>
         <Entry value="2" text="Extract Cell Seeded Regions"/>
         <Entry value="3" text="Extract Specified Regions"/>
         <Entry value="4" text="Extract Largest Region"/>
         <Entry value="5" text="Extract All Regions"/>
         <Entry value="6" text="Extract Closes Point Region"/>
       </EnumerationDomain>
       <Documentation>
         Controls the extraction of connected surfaces.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ColorRegions"
        command="SetColorRegions"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Controls the coloring of the connected regions.
        </Documentation>
     </IntVectorProperty>

      <Hints>
        <Property name="ExtractionMode" show="0"/>
        <Property name="ColorRegions" show="0"/>
      </Hints>
   <!-- End PVConnectivityFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ImageClip" class="vtkImageClip" label="Crop">
    <Documentation
       long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
       short_help="Extract a volume of interest.">
The Crop filter extracts an area/volume of interest from a 2D image or a 3D volume by allowing the user to specify the minimum and maximum extents of each dimension of the data. Both the input and output of this filter are uniform rectilinear data.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Crop filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="OutputWholeExtent"
        command="SetOutputWholeExtent"
        number_of_elements="6"
        default_values="0 0 0 0 0 0">
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
         This property gives the minimum and maximum point index (extent) in each dimension for the output dataset.
       </Documentation>
     </IntVectorProperty>
    <Hints>
      <Visibility replace_input="0" />
    </Hints>
   <!-- End ImageClip -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Curvatures" class="vtkCurvatures" label="Curvature">
    <Documentation
       long_help="This filter will compute the Gaussian or mean curvature of the mesh at each point."
       short_help="Compute the curvature at each point.">
The Curvature filter computes the curvature at each point in a polygonal data set. This filter supports both Gaussian and mean curvatures.

; the type can be selected from the Curvature type menu button.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Curvature filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="InvertMeanCurvature"
        command="SetInvertMeanCurvature"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the mean curvature calculation will be inverted. This is useful for meshes with inward-pointing normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="CurvatureType"
        command="SetCurvatureType"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Gaussian"/>
         <Entry value="1" text="Mean"/>
       </EnumerationDomain>
       <Documentation>
         This propery specifies which type of curvature to compute.
       </Documentation>
     </IntVectorProperty>
   <!-- End Curvatures -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="DecimatePro" class="vtkDecimatePro" label="Decimate">
     <Documentation
        long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
        short_help="Reduce the number of triangles in a model.">
The Decimate filter reduces the number of triangles in a polygonal data set. Because this filter only operates on triangles, first run the Triangulate filter on a dataset that contains polygons other than triangles.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Decimate filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="TargetReduction"
         command="SetTargetReduction"
         number_of_elements="1"
         animateable="1"
         default_values="0.9" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          This property specifies the desired reduction in the total number of polygons in the output dataset. For example, if the TargetReduction value is 0.9, the Decimate filter will attempt to produce an output dataset that is 10% the size of the input.)
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty
        name="PreserveTopology"
        command="SetPreserveTopology"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, decimation will not split the dataset or produce holes, but it may keep the filter from reaching the reduction target. If it is set to 0, better reduction can occur (reaching the reduction target), but holes in the model may be produced.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="15.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         The value of thie property is used in determining where the data set may be split. If the angle between two adjacent triangles is greater than or equal to the FeatureAngle value, then their boundary is considered a feature edge where the dataset can be split.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="BoundaryVertexDeletion"
        command="SetBoundaryVertexDeletion"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, then vertices on the boundary of the dataset can be removed. Setting the value of this property to 0 preserves the boundary of the dataset, but it may cause the filter not to reach its reduction target.
       </Documentation>
     </IntVectorProperty>
   <!-- End DecimatePro -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="D3" class="vtkDistributedDataFilter" label="D3"
                multiprocess_support="multiple_processes">
    <Documentation
       long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
       short_help="Repartition a data set.">
The D3 filter is available when ParaView is run in parallel. It operates on any type of data set to evenly divide it across the processors into spatially contiguous regions. The output of this filter is of type unstructured grid.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the D3 filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="BoundaryMode"
        command="SetBoundaryMode"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Assign cells uniquely"/>
         <Entry value="1" text="Duplicate cells"/>
         <Entry value="2" text="Divide cells"/>
       </EnumerationDomain>
       <Documentation>
         This property determines how cells that lie on processor boundaries are handled. The "Assign cells uniquely" option assigns each boundary cell to exactly one process, which is useful for isosurfacing. Selecting "Duplicate cells" causes the cells on the boundaries to be copied to each process that shares that boundary. The "Divide cells" option breaks cells across process boundary lines so that pieces of the cell lie in different processes. This option is useful for volume rendering.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseMinimalMemory"
        command="SetUseMinimalMemory"
        number_of_elements="1"
        default_values="0"
        label="Minimal Memory">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the D3 filter requires communication routines to use minimal memory than without this restriction.
       </Documentation>
     </IntVectorProperty>
   <!-- End D3 -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ElevationFilter" class="vtkElevationFilter" label="Elevation">
     <Documentation
        long_help="Create point attribute array by projecting points onto an elevation vector."
        short_help="Create a point array representing elevation.">
The Elevation filter generates point scalar values for an input dataset along a specified direction vector.

The Input menu allows the user to select the data set to which this filter will be applied. Use the Scalar range entry boxes to specify the minimum and maximum scalar value to be generated. The Low Point and High Point define a line onto which each point of the data set is projected. The minimum scalar value is associated with the Low Point, and the maximum scalar value is associated with the High Point. The scalar value for each point in the data set is determined by the location along the line to which that point projects.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input dataset to the Elevation filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ScalarRange"
         command="SetScalarRange"
         number_of_elements="2"
         default_values="0 1" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property determines the range into which scalars will be mapped.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="LowPoint"
         label="Low Point"
         command="SetLowPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 0" >
         <BoundsDomain name="range" mode="normal" default_mode="min" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           This property defines one end of the direction vector (small scalar values).
         </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="HighPoint"
         label="High Point"
         command="SetHighPoint"
         number_of_elements="3"
         animateable="1"
         default_values="0 0 1" >
         <BoundsDomain name="range" mode="normal" default_mode="max" >
           <RequiredProperties>
             <Property name="Input" function="Input" />
           </RequiredProperties>
         </BoundsDomain>
         <Documentation>
           This property defines the other end of the direction vector (large scalar values).
         </Documentation>
      </DoubleVectorProperty>

      <Hints>
        <PropertyGroup type="Line" label="Elevation Widget">
          <Property function="Point1WorldPosition" name="LowPoint" />
          <Property function="Point2WorldPosition" name="HighPoint" />
        </PropertyGroup>
      </Hints>
   <!-- End ElevationFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CTHPart" class="vtkExtractCTHPart"
    label="Extract CTH Parts">
    <Documentation
       long_help="Create a surface from a CTH volume fraction."
       short_help="Extract a part from a CTH dataset.">
Extract CTH Parts is a specialized filter for visualizing the data from a CTH simulation. It first converts the selected cell-centered arrays to point-centered ones. It then contours each array at a value of 0.5. The user has the option of clipping the resulting surface(s) with a plane. This filter only operates on unstructured data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="cell"
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Extract CTH Parts filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipPlane" command="SetClipPlane"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="None" />
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             This property specifies whether to clip the dataset, and if so, it also specifies the parameters of the plane with which to clip.
           </Documentation>
     </ProxyProperty>

     <StringVectorProperty
        name="AddDoubleVolumeArrayName"
        command="AddDoubleVolumeArrayName"
        clean_command="RemoveDoubleVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Double Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_DOUBLE" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty>

     <StringVectorProperty
        name="AddFloatVolumeArrayName"
        command="AddFloatVolumeArrayName"
        clean_command="RemoveFloatVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Float Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_FLOAT" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty>

     <StringVectorProperty
        name="AddUnsignedCharVolumeArrayName"
        command="AddUnsignedCharVolumeArrayName"
        clean_command="RemoveUnsignedCharVolumeArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Unsigned Character Volume Arrays">
        <Documentation>
          This property specifies the name(s) of the volume fraction array(s) for generating parts.
        </Documentation>
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_UNSIGNED_CHAR" >
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
            not set the default value for this property
            using the domain when the proxy is created -->
          <NoDefault />
        </Hints>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        number_of_elements="1"
        default_values="0.1"
        label="Volume Fraction Value">
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         The value of this property is the volume fraction value for the surface.
       </Documentation>
     </DoubleVectorProperty>
    <!-- End CTHPart -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractEdges" class="vtkExtractEdges"
      label="Extract Edges">
     <Documentation
        long_help="Extract edges of 2D and 3D cells as lines."
        short_help="Covert data to wireframe.">
The Extract Edges filter produces a wireframe version of the input dataset by extracting all the edges of the dataset's cells as lines. This filter operates on any type of data set and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Edges filter.
           </Documentation>
      </InputProperty>
   <!-- End ExtractEdges -->
   </SourceProxy>

   <SourceProxy name="DataSetSurfaceFilter" class="vtkDataSetSurfaceFilter"
      label="Extract Surface">
     <Documentation
        long_help="Extract a 2D boundary surface using neighbor relations to eliminate internal faces."
        short_help="Extract 2D boundary surface.">
The Extract Surface filter extracts the polygons forming the outer surface of the input dataset. This filter operates on any type of data and produces polygonal data as output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Surface filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="PieceInvariant"
        command="SetPieceInvariant"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, internal surfaces along process boundaries will be removed. NOTE: Enabling this option might cause multiple executions of the data source because more information is needed to remove internal surfaces.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="NonlinearSubdivisionLevel"
                        command="SetNonlinearSubdivisionLevel"
                        number_of_elements="1"
                        default_values="1">
       <IntRangeDomain name="range" min="0" max="4" />
       <Documentation>
         If the input is an unstructured grid with nonlinear faces, this
         parameter determines how many times the face is subdivided into
         linear faces.  If 0, the output is the equivalent of its linear
         couterpart (and the midpoints determining the nonlinear
         interpolation are discarded).  If 1, the nonlinear face is
         triangulated based on the midpoints.  If greater than 1, the
         triangulated pieces are recursively subdivided to reach the
         desired subdivision.  Setting the value to greater than 1 may
         cause some point data to not be passed even if no quadratic faces
         exist.  This option has no effect if the input is not an
         unstructured grid.
       </Documentation>
     </IntVectorProperty>
   <!-- End DataSetSurfaceFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Calculator" class="vtkPVArrayCalculator">
    <Documentation
       long_help="Compute new attribute arrays as function of existing arrays."
       short_help="Compute new attribute arrays.">
The Calculator filter computes a new data array or new point coordinates as a function of existing scalar or vector arrays. If point-centered arrays are used in the computation of a new data array, the resulting array will also be point-centered. Similarly, computations using cell-centered arrays will produce a new cell-centered array. If the function is computing point coordinates, the result of the function must be a three-component vector. The Calculator interface operates similarly to a scientific calculator. In creating the function to evaluate, the standard order of operations applies.
Each of the calculator functions is described below. Unless otherwise noted, enclose the operand in parentheses using the ( and ) buttons.
Clear: Erase the current function (displayed in the read-only text box above the calculator buttons).
/: Divide one scalar by another. The operands for this function are not required to be enclosed in parentheses.
*: Multiply two scalars, or multiply a vector by a scalar (scalar multiple). The operands for this function are not required to be enclosed in parentheses.
-: Negate a scalar or vector (unary minus), or subtract one scalar or vector from another. The operands for this function are not required to be enclosed in parentheses.
+: Add two scalars or two vectors. The operands for this function are not required to be enclosed in parentheses.
sin: Compute the sine of a scalar.
cos: Compute the cosine of a scalar.
tan: Compute the tangent of a scalar.
asin: Compute the arcsine of a scalar.
acos: Compute the arccosine of a scalar.
atan: Compute the arctangent of a scalar.
sinh: Compute the hyperbolic sine of a scalar.
cosh: Compute the hyperbolic cosine of a scalar.
tanh: Compute the hyperbolic tangent of a scalar.
min: Compute minimum of two scalars.
max: Compute maximum of two scalars.
x^y: Raise one scalar to the power of another scalar. The operands for this function are not required to be enclosed in parentheses.
sqrt: Compute the square root of a scalar.
e^x: Raise e to the power of a scalar.
log: Compute the logarithm of a scalar (deprecated. same as log10).
log10: Compute the logarithm of a scalar to the base 10.
ln: Compute the logarithm of a scalar to the base 'e'.
ceil: Compute the ceiling of a scalar.
floor: Compute the floor of a scalar.
abs: Compute the absolute value of a scalar.
v1.v2: Compute the dot product of two vectors. The operands for this function are not required to be enclosed in parentheses.
cross: Compute cross product of two vectors.
mag: Compute the magnitude of a vector.
norm: Normalize a vector.
The operands are described below.
The digits 0 - 9 and the decimal point are used to enter constant scalar values.
iHat, jHat, and kHat are vector constants representing unit vectors in the X, Y, and Z directions, respectively.
The scalars menu lists the names of the scalar arrays and the components of the vector arrays of either the point-centered or cell-centered data. The vectors menu lists the names of the point-centered or cell-centered vector arrays. The function will be computed for each point (or cell) using the scalar or vector value of the array at that point (or cell).
The filter operates on any type of data set, but the input data set must have at least one scalar or vector array. The arrays can be either point-centered or cell-centered. The Calculator filter's output is of the same data set type as the input.
    </Documentation>

    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input dataset to the Calculator filter. The scalar and vector variables may be chosen from this dataset's arrays.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="ResultArrayName"
        command="SetResultArrayName"
        number_of_elements="1"
        default_values="Result">
        <Documentation>
          This property contains the name for the output array containing the result of this computation.
        </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="Function"
        command="SetFunction"
        number_of_elements="1">
        <Documentation>
          This property contains the equation for computing the new array.
        </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="CoordinateResults"
        command="SetCoordinateResults"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether the results of this computation should be used as point coordinates or as a new array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="AttributeMode"
        command="SetAttributeMode"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="point_data"/>
         <Entry value="2" text="cell_data"/>
         <Entry value="5" text="field_data"/>
       </EnumerationDomain>
       <Documentation>
         This property determines whether the computation is to be performed on point-centered or cell-centered data.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ReplaceInvalidValues"
        label="Replace Invalid Results"
        command="SetReplaceInvalidValues"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This property determines whether invalid values in the computation will be replaced with a specific value. (See the ReplacementValue property.)
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ReplacementValue"
        command="SetReplacementValue"
        number_of_elements="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If invalid values in the computation are to be replaced with another value, this property contains that value.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End Calculator -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="FeatureEdges" class="vtkFeatureEdges"
    label="Feature Edges">
    <Documentation
       long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
       short_help="Extract edges that meet the feature criteria.">
The Feature Edges filter extracts various subsets of edges from the input data set. This filter operates on polygonal data and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Feature Edges filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="BoundaryEdges"
        command="SetBoundaryEdges"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, boundary edges will be extracted. Boundary edges are defined as lines cells or edges that are used by only one polygon.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="FeatureEdges"
        command="SetFeatureEdges"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, feature edges will be extracted. Feature edges are defined as edges that are used by two polygons whose dihedral angle is greater than the feature angle. (See the FeatureAngle property.)
         Toggle whether to extract feature edges.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="NonManifoldEdges"
        command="SetNonManifoldEdges"
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Edges">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, non-manifold ediges will be extracted. Non-manifold edges are defined as edges that are use by three or more polygons.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ManifoldEdges"
        command="SetManifoldEdges"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, manifold edges will be extracted. Manifold edges are defined as edges that are used by exactly two polygons.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Coloring"
        command="SetColoring"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, then the extracted edges are assigned a scalar value based on the type of the edge.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="30.0" >
       <DoubleRangeDomain name="range" min="0" max="180" />
       <Documentation>
         Ths value of this property is used to define a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists. (See the FeatureEdges property.)
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End FeatureEdges -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Gradient" class="vtkImageGradient" label="Gradient">
    <Documentation
      short_help="Compute gradient vectors."
      long_help="This filter computes gradient vectors for an image/volume.">
The Gradient filter computes the gradient vector at each point in an image or volume. This filter uses central differences to compute the gradients. The Gradient filter operates on uniform rectilinear (image) data and produces image data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Gradient filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property lists the name of the array from which to compute the gradient.
           </Documentation>
     </StringVectorProperty>
     <IntVectorProperty
        name="Dimensionality"
        command="SetDimensionality"
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates whether to compute the gradient in two dimensions or in three. If the gradient is being computed in two dimensions, the X and Y dimensions are used.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="UnstructuredGradient" class="vtkGradientFilter"
     label="Gradient Of Unstructured DataSet">
     <Documentation
       short_help="Compute gradients for any type of dataset."
       long_help="Estimate the gradient for each point or cell in any type of dataset.">
The Gradient (Unstructured) filter estimates the gradient vector at each point or cell. It operates on any type of vtkDataSet, and the output is the same type as the input. If the dataset is a vtkImageData, use the Gradient filter instead; it will be more efficient for this type of dataset.
     </Documentation>
     <InputProperty name="Input" command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array">
         <RequiredProperties>
           <Property name="SelectInputScalars" function="FieldDataSelection"/>
         </RequiredProperties>
       </InputArrayDomain>
       <Documentation>
         This property specifies the input to the Gradient (Unstructured) filter.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectInputScalars"
                           command="SetInputArrayToProcess"
                           number_of_elements="5"
                           element_types="0 0 0 0 2"
                           label="Scalar Array">
       <ArrayListDomain name="array_list" attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <FieldDataDomain name="field_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         This property lists the name of the scalar array from which to compute the gradient.
       </Documentation>
     </StringVectorProperty>
     <StringVectorProperty name="ResultArrayName"
                           command="SetResultArrayName"
                           number_of_elements="1"
                           default_values="Gradients">
       <Documentation>
         This property provides a name for the output array containing the gradient vectors.
       </Documentation>
     </StringVectorProperty>
     <IntVectorProperty name="FasterApproximation"
                        command="SetFasterApproximation"
                        number_of_elements="1"
                        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         When this flag is on, the gradient filter will provide a less
         accurate (but close) algorithm that performs fewer derivative
         calculations (and is therefore faster).  The error contains some
         smoothing of the output data and some possible errors on the
         boundary.  This parameter has no effect when performing the
         gradient of cell data.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty name="ComputeVorticity"
                        command="SetComputeVorticity"
                        number_of_elements="1"
                        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         When this flag is on, the gradient filter will compute the
         vorticity/curl of a 3 component array.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty name="ComputeQCriterion"
                        command="SetComputeQCriterion"
                        number_of_elements="1"
                        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         When this flag is on, the gradient filter will compute the
         Q-criterion of a 3 component array.
       </Documentation>
     </IntVectorProperty>
   <!-- End UnstructuredGradient -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="GradientMagnitude" class="vtkImageGradientMagnitude"
      label="Gradient Magnitude">
     <Documentation
       short_help="Compute the gradient magnitude."
       long_help="Compute the magnitude of the gradient vectors for an image/volume.">
The Gradient Magnitude filter computes the magnitude of the gradient vector at each point in an image or volume. This filter operates on uniform rectilinear (image) data and produces image data output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkImageData"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="1"/>
           <Documentation>
             This property specifies the input to the Gradient Magnitude filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="Dimensionality"
        command="SetDimensionality"
        number_of_elements="1"
        default_values="3" >
       <EnumerationDomain name="enum">
         <Entry value="2" text="Two"/>
         <Entry value="3" text="Three"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates whether to compute the gradient magnitude in two or three dimensions. If computing the gradient magnitude in 2D, the gradients in X and Y are used for computing the gradient magnitude.
       </Documentation>
     </IntVectorProperty>
   <!-- End Gradient -->
   </SourceProxy>

  <!-- ==================================================================== -->
   <SourceProxy name="GridConnectivity" class="vtkGridConnectivity"
      label="Grid Connectivity">
     <Documentation
       short_help="Parallel connectivity and integration."
       long_help="Mass properties of connected fragments for unstructured grids.">
This filter works on multiblock unstructured grid inputs and also works in
parallel.  It Ignores any cells with a cell data Status value of 0.
It performs connectivity to distict fragments separately.  It then integrates
attributes of the fragments.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkUnstructuredGrid"/>
             <DataType value="vtkCompositeDataSet"/>
           </DataTypeDomain>
           <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>
   <!-- End Grid Fragment -->
   </SourceProxy>

  <!-- ==================================================================== -->
   <SourceProxy name="RectilinearGridConnectivity" class="vtkRectilinearGridConnectivity"
     label="Rectilinear Grid Connectivity">
     <Documentation
       short_help="Parallel fragments extraction and attributes integration on rectilinear grids."
       long_help="Parallel fragments extraction and attributes integration on rectilinear grids.">
         Extracts material fragments from multi-block vtkRectilinearGrid datasets
         based on the selected volume fraction array(s) and a fraction isovalue and
         integrates the associated attributes.
     </Documentation>

     <InputProperty
       name="Input"
       command="SetInputConnection">
         <ProxyGroupDomain name="groups">
           <Group name="sources"/>
           <Group name="filters"/>
         </ProxyGroupDomain>

         <DataTypeDomain name="input_type">
           <DataType value="vtkRectilinearGrid"/>
           <DataType value="vtkCompositeDataSet"/>
         </DataTypeDomain>

         <InputArrayDomain name="input_array" attribute_type="cell"
                           number_of_components="1"/>
         <Documentation>This property specifies the input of the filter.</Documentation>
     </InputProperty>

     <StringVectorProperty
       name="AddDoubleVolumeArrayName"
       command="AddDoubleVolumeArrayName"
       clean_command="RemoveDoubleVolumeArrayNames"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Double Volume Arrays">
       <Documentation>
         This property specifies the name(s) of the volume fraction array(s) for generating parts.
       </Documentation>
       <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_DOUBLE" >
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
         <NoDefault />
       </Hints>
     </StringVectorProperty>

     <StringVectorProperty
       name="AddFloatVolumeArrayName"
       command="AddFloatVolumeArrayName"
       clean_command="RemoveFloatVolumeArrayNames"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Float Volume Arrays">
       <Documentation>
         This property specifies the name(s) of the volume fraction array(s) for generating parts.
       </Documentation>
       <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_FLOAT" >
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
         <NoDefault />
       </Hints>
     </StringVectorProperty>

     <StringVectorProperty
       name="AddUnsignedCharVolumeArrayName"
       command="AddUnsignedCharVolumeArrayName"
       clean_command="RemoveUnsignedCharVolumeArrayNames"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Unsigned Character Volume Arrays">
       <Documentation>
         This property specifies the name(s) of the volume fraction array(s) for generating parts.
       </Documentation>
       <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_UNSIGNED_CHAR" >
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
         <NoDefault />
       </Hints>
     </StringVectorProperty>

     <DoubleVectorProperty
       name="VolumeFractionSurfaceValue"
       command="SetVolumeFractionSurfaceValue"
       number_of_elements="1"
       default_values="0.1"
       label="Volume Fraction Value">
       <DoubleRangeDomain name="range" min="0" max="1" />
       <Documentation>
         The value of this property is the volume fraction value for the surface.
       </Documentation>
     </DoubleVectorProperty>

   <!-- End Rectilinear Grid Connectivity -->
   </SourceProxy>

    <!-- ==================================================================== -->
    <!--<SourceProxy name="AMRDualClip" class="vtkAMRDualClip"
       label="AMR Clip">
      <Documentation
        short_help="Clip with decimation."
        long_help="Clip with scalars.  Tetrahedra.">
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" attribute_type="cell"
                          number_of_components="1"/>
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>

      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Contour By">
        <ArrayListDomain name="array_list" attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property specifies the name of the cell scalar array from which the clip filter will compute clipped cells.
        </Documentation>
      </StringVectorProperty>

      <DoubleVectorProperty
        name="ContourValue"
        command="SetIsoValue"
        label="Isosurface"
        number_of_elements="1"
        default_values="1" >
        animateable="1">
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>
          This property specifies the values at which to compute the isosurface.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
        name="DegenerateCells"
        command="SetEnableDegenerateCells"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is on, a transition mesh between levels is created.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MultiprocessCommunication"
        command="SetEnableMultiProcessCommunication"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is off, each process executes independantly.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MergePoints"
        command="SetEnableMergePoints"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Use more memory to merge points on the boundaries of blocks.
        </Documentation>
      </IntVectorProperty>
    </SourceProxy>-->

    <!-- ==================================================================== -->
    <SourceProxy name="AMRDualClip" class="vtkPVAMRDualClip" label="AMR Dual Clip">
      <Documentation
        short_help="Clip with decimation."
        long_help="Clip with scalars.  Tetrahedra.">
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet"/>
        </DataTypeDomain>
        <Documentation>This property specifies the input of the filter.</Documentation>
        <InputArrayDomain name="input_array" attribute_type="cell"
                          number_of_components="1"/>
      </InputProperty>

      <StringVectorProperty
        name="SelectMaterialArrays"
        command="AddInputCellArrayToProcess"
        clean_command="ClearInputCellArrayToProcess"
        number_of_elements="1"
        repeat_command="1">
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_UNSIGNED_CHAR">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>
          This property specifies the cell arrays from which the clip filter will
          compute clipped cells.
        </Documentation>
      </StringVectorProperty>

      <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        label="Volume Fraction Value"
        number_of_elements="1"
        default_values="0.1" >
        <DoubleRangeDomain name="scalar_range" min="0.0" max="1.0" />
          <!--<RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="AddInputCellArrayToProcess" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>-->
        <Documentation>
          This property specifies the values at which to compute the isosurface.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
        name="InternalDecimation"
        command="SetEnableInternalDecimation"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is on, internal tetrahedra are decimation
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MultiprocessCommunication"
        command="SetEnableMultiProcessCommunication"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is off, each process executes independantly.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MergePoints"
        command="SetEnableMergePoints"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Use more memory to merge points on the boundaries of blocks.
        </Documentation>
      </IntVectorProperty>
      <!-- End PV AMR Dual Clip -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy name="AMRDualContour" class="vtkPVAMRDualContour"
       label="AMR Contour">
      <Documentation
        short_help="Iso surface cell array.">
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <Documentation>This property specifies the input of the filter.</Documentation>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" attribute_type="cell"
                          number_of_components="1"/>
      </InputProperty>

      <StringVectorProperty
        name="SelectMaterialArrays"
        command="AddInputCellArrayToProcess"
        clean_command="ClearInputCellArrayToProcess"
        number_of_elements="1"
        repeat_command="1">
        <ArrayListDomain name="array_list" attribute_type="Scalars" data_type="VTK_UNSIGNED_CHAR">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>
          This property specifies the cell arrays from which the contour filter will
          compute contour cells.
        </Documentation>
      </StringVectorProperty>

      <DoubleVectorProperty
        name="VolumeFractionSurfaceValue"
        command="SetVolumeFractionSurfaceValue"
        label="Volume Fraction Value"
        number_of_elements="1"
        default_values="0.1" >
        <DoubleRangeDomain name="scalar_range" min="0.0" max="1.0" />
          <!--<RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="AddInputCellArrayToProcess" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>-->
        <Documentation>
          This property specifies the values at which to compute the isosurface.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
        name="Capping"
        command="SetEnableCapping"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is on, the the boundary of the data set is capped.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="DegenerateCells"
        command="SetEnableDegenerateCells"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is on, a transition mesh between levels is created.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MultiprocessCommunication"
        command="SetEnableMultiProcessCommunication"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is off, each process executes independantly.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="SkipGhostCopy"
        command="SetSkipGhostCopy"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          A simple test to see if ghost values are already set properly.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="Triangulate"
        command="SetTriangulateCap"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Use triangles instead of quads on capping surfaces.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MergePoints"
        command="SetEnableMergePoints"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Use more memory to merge points on the boundaries of blocks.
        </Documentation>
      </IntVectorProperty>


      <!-- End AMR Dual Contour -->
    </SourceProxy>

    <!-- ==================================================================== -->
   <SourceProxy name="CTHSurface" class="vtkCTHSimpleSurface"
      label="CTH Surface">
     <Documentation
       short_help="Creates surface for every block."
       long_help="Not finished yet.">
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <Documentation>This property specifies the input of the filter.</Documentation>
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkCompositeDataSet"/>
           </DataTypeDomain>
      </InputProperty>
   <!-- End CTH Simple Surface -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="LinearExtrusionFilter" class="vtkPVLinearExtrusionFilter"
    label="Linear Extrusion">
    <Documentation
       long_help="This filter creates a swept surface defined by translating the input along a vector."
       short_help="Generate a linear swept surface.">
The Linear Extrusion filter creates a swept surface by translating the input dataset along a specified vector. This filter is intended to operate on 2D polygonal data. This filter operates on polygonal data and produces polygonal data output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Linear Extrusion filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property determines the distance along the vector the dataset will be translated. (A scale factor of 0.5 will move the dataset half the length of the vector, and a scale factor of 2 will move it twice the vector's length.)
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Vector"
        command="SetVector"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property indicates the X, Y, and Z components of the vector along which to sweep the input dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="Capping"
        command="SetCapping"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property indicates whether to cap the ends of the swept surface. Capping works by placing a copy of the input dataset on either end of the swept surface, so it behaves properly if the input is a 2D surface composed of filled polygons. If the input dataset is a closed solid (e.g., a sphere), then if capping is on (i.e., this property is set to 1), two copies of the data set will be displayed on output (the second translated from the first one along the specified vector). If instead capping is off (i.e., this property is set to 0), then an input closed solid will produce no output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="PieceInvariant"
        command="SetPieceInvariant"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether the output will be the same regardless of the number of processors used to compute the result. The difference is whether there are internal polygonal faces on the processor boundaries. A value of 1 will keep the results the same; a value of 0 will allow internal faces on processor boundaries.
       </Documentation>
     </IntVectorProperty>
   <!-- End LinearExtrusionFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="LoopSubdivisionFilter" class="vtkLoopSubdivisionFilter"
    label="Loop Subdivision">
    <Documentation
       long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
       short_help="Create a higher resolution and smoother surface.">
The Loop Subdivision filter increases the granularity of a polygonal mesh. It works by dividing each triangle in the input into four new triangles. It is named for Charles Loop, the person who devised this subdivision scheme. This filter only operates on triangles, so a data set that contains other types of polygons should be passed through the Triangulate filter before applying this filter to it. This filter only operates on polygonal data (specifically triangle meshes), and it produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Loop Subdivision filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="NumberOfSubdivisions"
        command="SetNumberOfSubdivisions"
        number_of_elements="1"
        animateable="1"
        default_values="1"
        label="Number of Subdivisions">
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         Set the number of subdivision iterations to perform. Each subdivision divides single triangles into four new triangles.
       </Documentation>
     </IntVectorProperty>
   <!-- End LoopSubdivisionFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="MaskPoints" class="vtkPMaskPoints"
    label="Mask Points">
    <Documentation
          long_help="Reduce the number of points.  This filter is often used before glyphing. Generating vertices is an option."
          short_help="Reduce the number of points.">
The Mask Points filter reduces the number of points in the dataset. It operates on any type of dataset, but produces only points / vertices as output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Mask Points filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="OnRatio"
        command="SetOnRatio"
        number_of_elements="1"
        default_values="2" >
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         The value of this property specifies that every OnStride-th points will be retained in the output when not using Random (the skip or stride size for point ids). (For example, if the on ratio is 3, then the output will contain every 3rd point, up to the the maximum number of points.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfPoints"
        command="SetMaximumNumberOfPoints"
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property indicates the maximum number of points in the output dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ProportionalMaximumNumberOfPoints"
        command="SetProportionalMaximumNumberOfPoints"
        number_of_elements="1"
        default_values="0"
        label="Proportionally Distribute Maximum Number Of Points">
       <BooleanDomain name="bool"/>
       <Documentation>
        When this is off, the maximum number of points is taken per processor when running in parallel (total number of points = number of processors * maximum number of points).  When this is on, the maximum number of points is proportionally distributed across processors depending on the number of points per processor (total number of points = maximum number of points; maximum number of points per processor = number of points on a processor * maximum number of points / total number of points across all processors).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Offset"
        command="SetOffset"
        number_of_elements="1"
        animateable="1"
        default_values="0" >
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property indicates the starting point id in the ordered list of input points from which to start masking.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="RandomMode"
        command="SetRandomMode"
        number_of_elements="1"
        default_values="0"
        label="Random Sampling">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to true, then the points in the output will be randomly selected from the input in various ways set by Random Mode; otherwise this filter will subsample point ids regularly.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="RandomModeType"
        command="SetRandomModeType"
        number_of_elements="1"
        default_values="0"
        label="Random Sampling Mode">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Randomized Id Strides"/>
         <Entry value="1" text="Random Sampling"/>
         <Entry value="2" text="Spatially Stratified Random Sampling"/>
       </EnumerationDomain>
       <Documentation>
         Randomized Id Strides picks points with random id increments starting at Offset (the output probably isn't a statistically random sample).  Random Sampling generates a statistically random sample of the input, ignoring Offset (fast - O(sample size)).  Spatially Stratified Random Sampling is a variant of random sampling that splits the points into equal sized spatial strata before randomly sampling (slow - O(N log N)).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="GenerateVertices"
        command="SetGenerateVertices"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This property specifies whether to generate vertex cells as the topography of the output. If set to 1, the geometry (vertices) will be displayed in the rendering window; otherwise no geometry will be displayed.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="SingleVertexPerCell"
        command="SetSingleVertexPerCell"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Tell filter to only generate one vertex per cell instead of multiple vertices in one cell.
       </Documentation>
     </IntVectorProperty>
     <!-- End MaskPoints -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Median" class="vtkImageMedian3D">
    <Documentation
      short_help="Compute median values in a given neighborhood."
      long_help="Compute the median scalar values in a specified neighborhood for image/volume datasets.">
The Median filter operates on uniform rectilinear (image or volume) data and produces uniform rectilinear output. It replaces the scalar value at each pixel / voxel with the median scalar value in the specified surrounding neighborhood. Since the median operation removes outliers, this filter is useful for removing high-intensity, low-probability noise (shot noise).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1"/>
          <Documentation>
            This property specifies the input to the Median filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of thie property lists the name of the scalar array to use in computing the median.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="KernelSize"
        command="SetKernelSize"
        number_of_elements="3"
        default_values="1 1 1" >
       <IntRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the number of pixels/voxels in each dimension to use in computing the median to assign to each pixel/voxel. If the kernel size in a particular dimension is 1, then the median will not be computed in that direction.
       </Documentation>
     </IntVectorProperty>
   <!-- End Median -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="MeshQuality" class="vtkMeshQuality"
    label="Mesh Quality">
    <Documentation
       long_help="This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes."
       short_help="Evaluate geometric mesh quality.">
This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes. Supported shapes include triangles, quadrilaterals, tetrahedra, and hexahedra. For other shapes, a value of 0 is assigned.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Mesh Quality filter.
          </Documentation>
     </InputProperty>
     <IntVectorProperty
        name="TriangleQualityMeasure"
        command="SetTriangleQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="8" text="Maximum Angle"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate triangle quality. The radius ratio is the size of a circle circumscribed by a triangle's 3 vertices divided by the size of a circle tangent to a triangle's 3 edges. The edge ratio is the ratio of the longest edge length to the shortest edge length.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="QuadQualityMeasure"
        command="SetQuadQualityMeasure"
        number_of_elements="1"
        default_values="0">
       <EnumerationDomain name="enum">
         <Entry value="28" text="Area"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="4" text="Mean Aspect Frobenius"/>
         <Entry value="6" text="Minimum Angle"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="11" text="Shear"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="17" text="Skew"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="18" text="Taper"/>
         <Entry value="26" text="Warpage"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate quadrilateral quality.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="TetQualityMeasure"
        command="SetTetQualityMeasure"
        number_of_elements="1"
        default_values="2">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="29" text="Aspect Beta"/>
         <Entry value="27" text="Aspect Gamma"/>
         <Entry value="3" text="Aspect Frobenius"/>
         <Entry value="1" text="Aspect Ratio"/>
         <Entry value="7" text="Collapse Ratio"/>
         <Entry value="9" text="Condition"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="6" text="Minimum Dihedral Angle"/>
         <Entry value="2" text="Radius Ratio"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="19" text="Volume"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate tetrahedral quality. The radius ratio is the size of a sphere circumscribed by a tetrahedron's 4 vertices divided by the size of a circle tangent to a tetrahedron's 4 faces. The edge ratio is the ratio of the longest edge length to the shortest edge length. The collapse ratio is the minimum ratio of height of a vertex above the triangle opposite it divided by the longest edge of the opposing triangle across all vertex/triangle pairs.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="HexQualityMeasure"
        command="SetHexQualityMeasure"
        number_of_elements="1"
        default_values="5">
       <EnumerationDomain name="enum">
         <Entry value="21" text="Diagonal"/>
         <Entry value="22" text="Dimension"/>
         <Entry value="15" text="Distortion"/>
         <Entry value="0" text="Edge Ratio"/>
         <Entry value="25" text="Jacobian"/>
         <Entry value="16" text="Maximum Edge Ratio"/>
         <Entry value="5" text="Maximum Aspect Frobenius"/>
         <Entry value="4" text="Mean Aspect Frobenius"/>
         <Entry value="23" text="Oddy"/>
         <Entry value="12" text="Relative Size Squared"/>
         <Entry value="10" text="Scaled Jacobian"/>
         <Entry value="13" text="Shape"/>
         <Entry value="14" text="Shape and Size"/>
         <Entry value="11" text="Shear"/>
         <Entry value="24" text="Shear and Size"/>
         <Entry value="17" text="Skew"/>
         <Entry value="20" text="Stretch"/>
         <Entry value="18" text="Taper"/>
         <Entry value="19" text="Volume"/>
       </EnumerationDomain>
       <Documentation>
         This property indicates which quality measure will be used to evaluate hexahedral quality.
       </Documentation>
     </IntVectorProperty>
   <!-- End MeshQuality -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PolyDataNormals" class="vtkPPolyDataNormals"
    label="Generate Surface Normals">
    <Documentation
       long_help="This filter will produce surface normals used for smooth shading. Splitting is used to avoid smoothing across feature edges."
       short_help="Produce surface point normals.">
This filter generates surface normals at the points of the input polygonal dataset to provide smooth shading of the dataset. The resulting dataset is also polygonal. The filter works by calculating a normal vector for each polygon in the dataset and then averaging the normals at the shared points.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Normals Generation filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="FeatureAngle"
        command="SetFeatureAngle"
        number_of_elements="1"
        default_values="30" >
       <DoubleRangeDomain name="range" min="0" max="180"/>
       <Documentation>
         The value of this property  defines a feature edge. If the surface normal between two adjacent triangles is at least as large as this Feature Angle, a feature edge exists. If Splitting is on, points are duplicated along these feature edges. (See the Splitting property.)
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="Splitting"
        command="SetSplitting"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This property controls the splitting of sharp edges. If sharp edges are split (property value = 1), then points are duplicated along these edges, and separate normals are computed for both sets of points to give crisp (rendered) surface definition.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Consistency"
        command="SetConsistency"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property controls whether consistent polygon ordering is enforced. Generally the normals for a data set should either all point inward or all point outward. If the value of this property is 1, then this filter will reorder the points of cells that whose normal vectors are oriented the opposite direction from the rest of those in the data set.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="FlipNormals"
        command="SetFlipNormals"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, this filter will reverse the normal direction (and reorder the points accordingly) for all polygons in the data set; this changes front-facing polygons to back-facing ones, and vice versa. You might want to do this if your viewing position will be inside the data set instead of outside of it.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="NonManifoldTraversal"
        command="SetNonManifoldTraversal"
        number_of_elements="1"
        default_values="1"
        label="Non-Manifold Traversal">
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn on/off traversal across non-manifold edges. Not traversing non-manifold edges will prevent problems where the consistency of polygonal ordering is corrupted due to topological loops.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeCellNormals"
        command="SetComputeCellNormals"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This filter computes the normals at the points in the data set. In the process of doing this it computes polygon normals too. If you want these normals to be passed to the output of this filter, set the value of this property to 1.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="PieceInvariant"
        command="SetPieceInvariant"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Turn this option to to produce the same results regardless of the number of processors used (i.e., avoid seams along processor boundaries). Turn this off if you do want to process ghost levels and do not mind seams.
       </Documentation>
     </IntVectorProperty>
   <!-- End  PolyDataNormals -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="OutlineFilter" class="vtkPOutlineFilter"
     label="Outline">
     <Documentation
        long_help="This filter generates a bounding box representation of the input."
        short_help="Generates a bounding box.">
The Outline filter generates an axis-aligned bounding box for the input dataset. This filter operates on any type of dataset and produces polygonal output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Outline filter.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End  OutlineFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="OutlineCornerFilter" class="vtkPOutlineCornerFilter"
    label="Outline Corners">
    <Documentation
       long_help="This filter generates a bounding box representation of the input. It only displays the corners of the bounding box."
       short_help="Generates corners of a bounding box.">
The Outline Corners filter generates the corners of a bounding box for the input dataset. This filter operates on any type of dataset and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Outline Corners filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="CornerFactor"
        command="SetCornerFactor"
        number_of_elements="1"
        default_values="0.2" >
       <DoubleRangeDomain name="range" min="0.001" max="0.5" />
       <Documentation>
         The value of this property sets the size of the corners as a percentage of the length of the corresponding bounding box edge.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  OutlineCornerFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="OctreeDepthScalars" class="vtkHyperOctreeDepth"
     label="Octree Depth Scalars">
     <Documentation
        long_help="This filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree."
        short_help="Computes cell depths within the octree.">
The vtkHyperOctreeDepth filter adds a scalar to each leaf of the octree that represents the leaf's depth within the tree.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Octree Depth Scalars filter.
           </Documentation>
      </InputProperty>
   <!-- End  OctreeDepthScalars-->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="OctreeDepthLimit" class="vtkHyperOctreeLimiter"
     label="Octree Depth Limit">
     <Documentation
        long_help="This filter takes in a octree and produces a new octree which is no deeper than the maximum specified depth level."
        short_help="Reduce an octree's resolution.">
The Octree Depth Limit filter takes in an octree and produces a new octree that is nowhere deeper than the maximum specified depth level. The attribute data of pruned leaf cells are integrated in to their ancestors at the cut level.
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHyperOctree"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Octree Depth Limit filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="MaximumLevel"
        command="SetMaximumLevel"
        number_of_elements="1"
        default_values="4" >
       <IntRangeDomain name="range" min="3" max="255"/>
       <Documentation>
         The value of this property specifies the maximum depth of the output octree.
       </Documentation>
     </IntVectorProperty>
   <!-- End  OctreeDepthLimit-->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ProcessIdScalars" class="vtkProcessIdScalars"
                label="Process Id Scalars"
                multiprocess_support="multiple_processes">
     <Documentation
        long_help="This filter uses colors to show how data is partitioned across processes."
        short_help="Generate point scalars from process id.">
The Process Id Scalars filter assigns a unique scalar value to each piece of the input according to which processor it resides on. This filter operates on any type of data when ParaView is run in parallel. It is useful for determining whether your data is load-balanced across the processors being used. The output data set type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Process Id Scalars filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="RandomMode"
        command="SetRandomMode"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property determines whether to use random id values for the various pieces. If set to 1, the unique value per piece will be chosen at random; otherwise the unique value will match the id of the process.
       </Documentation>
     </IntVectorProperty>
   <!-- End PieceScalars -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PointDataToCellData" class="vtkPointDataToCellData"
     label="Point Data to Cell Data">
     <Documentation
        long_help="Create cell attributes by averaging point attributes."
        short_help="Convert point data to cell data.">
The Point Data to Cell Data filter averages the values of the point attributes of the points of a cell to compute cell attributes. This filter operates on any type of dataset, and the output dataset is the same type as the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"/>
           <FixedTypeDomain name="fixed_type"/>
           <Documentation>
             This property specifies the input to the Point Data to Cell Data filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="PassPointData"
        command="SetPassPointData"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         The value of this property controls whether the input point data will be passed to the output. If set to 1, then the input point data is passed through to the output; otherwise, only generated cell data is placed into the output.
       </Documentation>
     </IntVectorProperty>
   <!-- End PointDataToCellData -->
   </SourceProxy>

  <!--
  <SourceProxy
      name="QuadraturePointStatistics"
      class="vtkQuadraturePointStatistics"
      label="Quadrature Point Statistics">

    <Documentation
        long_help="Compute basics statistics over data fields interpolated to quadrature points."
        short_help="Compute basics statistics over data fields interpolated to quadrature points.">
        "Compute basics statistics over data fields interpolated to quadrature points."
    </Documentation>

    <InputProperty
        name="Input"
        command="SetInputConnection">

      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>

      <DataTypeDomain name="input_type">
        <DataType value="vtkUnstructuredGrid"/>
      </DataTypeDomain>
      <Documentation>This property specifies the input of the filter.</Documentation>
    </InputProperty>
  </SourceProxy>
   ############################################################################ -->
   <!-- ############################################################################ -->
  <SourceProxy
      name="QuadraturePointInterpolator"
      class="vtkQuadraturePointInterpolator"
      label="Interpolate to Quadrature Points">

    <Documentation
        long_help="Create scalar/vector data arrays interpolated to quadrature points."
        short_help="Create scalar/vector data arrays interpolated to quadrature points.">
        "Create scalar/vector data arrays interpolated to quadrature points."
    </Documentation>

    <InputProperty
        name="Input"
        command="SetInputConnection">

      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>

      <DataTypeDomain name="input_type">
        <DataType value="vtkUnstructuredGrid"/>
      </DataTypeDomain>
      <Documentation>This property specifies the input of the filter.</Documentation>
    </InputProperty>

    <StringVectorProperty
        name="SelectSourceArray"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0">
      <Documentation>
        Specifies the offset array from which we interpolate values to quadrature points.
      </Documentation>
      <ArrayListDomain
          name="array_list"
          data_type="VTK_ID_TYPE"
          attribute_type="Scalars"
          key_locations="vtkQuadratureSchemeDefinition"
          key_names="DICTIONARY"
          key_strategies="NEED_KEY">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
      </ArrayListDomain>
    </StringVectorProperty>
  </SourceProxy>
  <!-- ############################################################################ -->
  <SourceProxy
      name="QuadraturePointsGenerator"
      class="vtkQuadraturePointsGenerator"
      label="Generate Quadrature Points">

    <Documentation
        long_help="Create a point set with data at quadrature points."
        short_help="Create a point set with data at quadrature points.">
        "Create a point set with data at quadrature points."
    </Documentation>

    <OutputPort name="Quadrature Points" index="0" />

    <InputProperty
        name="Input"
        command="SetInputConnection">

      <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
      </ProxyGroupDomain>

      <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid"/>
      </DataTypeDomain>
      <InputArrayDomain
          name="input_array"
          attribute_type="cell"/>
       <Documentation>This property specifies the input of the filter.</Documentation>
    </InputProperty>

    <!-- Source Array-->
    <StringVectorProperty
        name="SelectSourceArray"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0">
      <Documentation>
        Specifies the offset array from which we generate quadrature points.
      </Documentation>
      <ArrayListDomain
          name="array_list"
          data_type="VTK_ID_TYPE"
          attribute_type="Scalars"
          key_locations="vtkQuadratureSchemeDefinition"
          key_names="DICTIONARY"
          key_strategies="NEED_KEY">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
      </ArrayListDomain>
    </StringVectorProperty>
  </SourceProxy>
  <!-- ############################################################################ -->
  <SourceProxy
      name="QuadratureSchemeDictionaryGenerator"
      class="vtkQuadratureSchemeDictionaryGenerator"
      label="Generate Quadrature Scheme Dictionary">

    <Documentation
        long_help="Generate quadrature scheme dictionaries in data sets that do not have them."
        short_help="Generate quadrature scheme dictionaries in data sets that do not have them.">
        Generate quadrature scheme dictionaries in data sets that do not have them.
    </Documentation>

    <InputProperty
        name="Input"
        command="SetInputConnection">

      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>

      <DataTypeDomain name="input_type">
        <DataType value="vtkUnstructuredGrid"/>
      </DataTypeDomain>
      <Documentation>This property specifies the input of the filter.</Documentation>
    </InputProperty>
  </SourceProxy>


   <!-- ==================================================================== -->
   <SourceProxy name="QuadricClustering" class="vtkQuadricClustering"
    label="Quadric Clustering">
    <Documentation
       long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
       short_help="Simplify polygonal models.">
The Quadric Clustering filter produces a reduced-resolution polygonal approximation of the input polygonal dataset. This filter is the one used by ParaView for computing LODs. It uses spatial binning to reduce the number of points in the data set; points that lie within the same spatial bin are collapsed into one representative point.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Quadric Clustering filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="NumberOfDivisions"
        command="SetNumberOfDivisions"
        number_of_elements="3"
        default_values="50 50 50"
        label="Number of Dimensions" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the number of bins along the X, Y, and Z axes of the data set.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseInputPoints"
        command="SetUseInputPoints"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, the representative point for each bin is selected from one of the input points that lies in that bin; the input point that produces the least error is chosen. If the value of this property is 0, the location of the representative point is calculated to produce the least error possible for that bin, but the point will most likely not be one of the input points.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseFeatureEdges"
        command="SetUseFeatureEdges"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, feature edge quadrics will be used to maintain the boundary edges along processor divisions.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseFeaturePoints"
        command="SetUseFeaturePoints"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, feature point quadrics will be used to maintain the boundary points along processor divisions.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="CopyCellData"
        command="SetCopyCellData"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the cell data from the input will be copied to the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseInternalTriangles"
        command="SetUseInternalTriangles"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, triangles completely contained in a spatial bin will be included in the computation of the bin's quadrics. When this property is set to 0, the filters operates faster, but the resulting surface may not be as well-behaved.
       </Documentation>
     </IntVectorProperty>
   <!-- End QuadricClustering -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="BrownianPoints" class="vtkBrownianPoints" label="Random Vectors">
    <Documentation
       long_help="This filter creates a new 3-component point data array and sets it as the default vector array. It uses a random number generator to create values."
       short_help="Create a new random vector array.">
The Random Vectors filter generates a point-centered array of random vectors. It uses a random number generator to determine the components of the vectors. This filter operates on any type of data set, and the output data set will be of the same type as the input.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Random Vectors filter.
          </Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="MinimumSpeed"
        command="SetMinimumSpeed"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range" min="0" />
       <Documentation>
         This property specifies the minimum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="MaximumSpeed"
        command="SetMaximumSpeed"
        number_of_elements="1"
        default_values="1" >
       <DoubleRangeDomain name="range" min="0"/>
       <Documentation>
         This property specifies the maximum length of the random point vectors generated.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End BrownianPoints -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ReflectionFilter" class="vtkPReflectionFilter"
    label="Reflect">
    <Documentation
       long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
       short_help="Reflect input over an axis aligned plane.">
The Reflect filter reflects the input dataset across the specified plane. This filter operates on any type of data set and produces an unstructured grid output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Reflect filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="Plane"
        command="SetPlane"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="X Min"/>
         <Entry value="1" text="Y Min"/>
         <Entry value="2" text="Z Min"/>
         <Entry value="3" text="X Max"/>
         <Entry value="4" text="Y Max"/>
         <Entry value="5" text="Z Max"/>
         <Entry value="6" text="X"/>
         <Entry value="7" text="Y"/>
         <Entry value="8" text="Z"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property determines which plane to reflect across. If the value is X, Y, or Z, the value of the Center property determines where the plane is placed along the specified axis. The other six options (X Min, X Max, etc.) place the reflection plane at the specified face of the bounding box of the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Center"
        command="SetCenter"
        number_of_elements="1"
        animateable="1"
        default_values="0.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If the value of the Plane property is X, Y, or Z, then the value of this property specifies the center of the reflection plane.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="CopyInput"
        command="SetCopyInput"
        number_of_elements="1"
        default_values="1">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the output will contain the union of the input dataset and its reflection. Otherwise the output will contain only the reflection of the input data.
       </Documentation>
     </IntVectorProperty>
   <!-- End ReflectionFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="RibbonFilter" class="vtkRibbonFilter"
    label="Ribbon">
    <Documentation
       long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
       short_help="Create ribbon surfaces from lines.">
The Ribbon filter creates ribbons from the lines in the input data set. This filter is useful for visualizing streamlines. Both the input and output of this filter are polygonal data. The input data set must also have at least one point-centered vector array.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            This property specifies the input to the Ribbon filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars"
                            input_domain_name="input_array2">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of this property indicates the name of the input scalar array used by this filter. The width of the ribbons will be varied based on the values in the specified array if the value of the Width property is 1.
           </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Vectors"> <!-- default_values=1, send vectors to the right place -->
           <ArrayListDomain name="array_list" attribute_type="Vectors"
                            input_domain_name="input_array1">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             The value of this property indicates the name of the input vector array used by this filter. If the UseDefaultNormal property is set to 0, the normal vectors for the ribbons come from the specified vector array.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="Width"
        command="SetWidth"
        number_of_elements="1"
        default_values="1" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         If the VaryWidth property is set to 1, the value of this property is the minimum ribbon width. If the VaryWidth property is set to 0, the value of this property is half the width of the ribbon.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range" min="0" max="360" />
       <Documentation>
         The value of this property specifies the offset angle (in degrees) of the ribbon from the line normal.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="UseDefaultNormal"
        command="SetUseDefaultNormal"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 0, and the input contains no vector array, then default ribbon normals will be generated (DefaultNormal property); if a vector array has been set (SelectInputVectors property), the ribbon normals will be set from the specified array. If this property is set to 1, the default normal (DefaultNormal property) will be used, regardless of whether the SelectInputVectors property has been set.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="DefaultNormal"
        command="SetDefaultNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the normal to use when the UseDefaultNormal property is set to 1 or the input contains no vector array (SelectInputVectors property).
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="VaryWidth"
        command="SetVaryWidth"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the ribbon width will be scaled according to the scalar array specified in the SelectInputScalars property.
         Toggle the variation of ribbon width with scalar value.
       </Documentation>
     </IntVectorProperty>
   <!-- End RibbonFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="RotationalExtrusionFilter"
                class="vtkRotationalExtrusionFilter"
                label="Rotational Extrusion">
    <Documentation
       long_help="This filter generates a swept surface while translating the input along a circular path."
       short_help="Generates a swept surface using a rotational path.">
The Rotational Extrusion filter forms a surface by rotating the input about the Z axis. This filter is intended to operate on 2D polygonal data. It produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Rotational Extrusion filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="Resolution"
        command="SetResolution"
        number_of_elements="1"
        default_values="12" >
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         The value of this property controls the number of intermediate node points used in performing the sweep (rotating from 0 degrees to the value specified by the Angle property.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Capping"
        command="SetCapping"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the open ends of the swept surface will be capped with a copy of the input dataset. This works property if the input is a 2D surface composed of filled polygons. If the input dataset is a closed solid (e.g., a sphere), then either two copies of the dataset will be drawn or no surface will be drawn. No surface is drawn if either this property is set to 0 or if the two surfaces would occupy exactly the same 3D space (i.e., the Angle property's value is a multiple of 360, and the values of the Translation and DeltaRadius properties are 0).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Angle"
        command="SetAngle"
        number_of_elements="1"
        animateable="1"
        default_values="360" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the angle of rotation in degrees. The surface is swept from 0 to the value of this property.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Translation"
        command="SetTranslation"
        number_of_elements="1"
        animateable="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the total amount of translation along the Z axis during the sweep process. Specifying a non-zero value for this property allows you to create a corkscrew (value of DeltaRadius > 0) or spring effect.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="DeltaRadius"
        command="SetDeltaRadius"
        number_of_elements="1"
        default_values="0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the change in radius during the sweep process.
       </Documentation>
     </DoubleVectorProperty>
   <!-- End RotationalExtrusionFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ShrinkFilter" class="vtkShrinkFilter"
                label="Shrink">
     <Documentation
        long_help="This filter shrinks each input cell so they pull away from their neighbors."
        short_help="Shrink each input cell.">
The Shrink filter causes the individual cells of a dataset to break apart from each other by moving each cell's points toward the centroid of the cell. (The centroid of a cell is the average position of its points.) This filter operates on any type of dataset and produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Shrink filter.
           </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="ShrinkFactor"
         command="SetShrinkFactor"
         number_of_elements="1"
         animateable="1"
         default_values="0.5" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          The value of this property determines how far the points will move. A value of 0 positions the points at the centroid of the cell; a value of 1 leaves them at their original positions.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End ShrinkFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="SmoothPolyDataFilter" class="vtkSmoothPolyDataFilter"
    label="Smooth">
    <Documentation
       long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
       short_help="Smooth a polygonal surface without adding more points.">
The Smooth filter operates on a polygonal data set by iteratively adjusting the position of the points using Laplacian smoothing. (Because this filter only adjusts point positions, the output data set is also polygonal.) This results in better-shaped cells and more evenly distributed points.

The Convergence slider limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the data set. If the maximum point motion during a smoothing iteration is less than the Convergence value, the smoothing operation terminates.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Smooth filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="NumberOfIterations"
        command="SetNumberOfIterations"
        number_of_elements="1"
        animateable="1"
        default_values="20"
        label="Number of Iterations">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         This property sets the maximum number of smoothing iterations to perform. More iterations produce better smoothing.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Convergence"
         command="SetConvergence"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          The value of this property limits the maximum motion of any point. It is expressed as a fraction of the length of the diagonal of the bounding box of the input dataset. If the maximum point motion during a smoothing iteration is less than the value of this property, the smoothing operation terminates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End SmoothPolyDataFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Stripper" class="vtkStripper"
    label="Triangle Strips">
    <Documentation
       long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
       short_help="Convert triangles into triangle strips.">
The Triangle Strips filter converts triangles into triangle strips and lines into polylines. This filter operates on polygonal data sets and produces polygonal output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Triangle Strips filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="MaximumLength"
        command="SetMaximumLength"
        number_of_elements="1"
        default_values="1000" >
       <IntRangeDomain name="range" min="4" max="100000"/>
       <Documentation>
         This property specifies the maximum number of triangles/lines to include in a triangle strip or polyline.
       </Documentation>
     </IntVectorProperty>
   <!-- End Stripper -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PlotOnSortedLines" class="vtkPlotEdges"
    label="Plot On Sorted Lines">
    <Documentation
       long_help=""
       short_help="">
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Plot Edges filter.
          </Documentation>
     </InputProperty>
    <Hints>
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="XYChartView" />

      <!-- Temporary hint to allow the output of this filter to be plotted -->
      <Plotable />
    </Hints>
   <!-- End PlotEdges -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <CompoundSourceProxy name="PlotOnIntersectionCurves" label="Plot On Intersection Curves">
     <Documentation
        short_help="Extracts the edges in a 2D plane and plots them"
        long_help="Extracts the edges in a 2D plane and plots them" >
       Extracts the surface, intersect it with a 2D plane.
       Plot the resulting polylines.
     </Documentation>
     <Proxy group="filters" type="DataSetSurfaceFilter" id="374" servers="1" compound_name="ExtractSurface1">
       <Property name="Input" id="374.Input" number_of_elements="1">
         <Domain name="groups" id="374.Input.groups">
           <Group value="sources"/>
           <Group value="filters"/>
         </Domain>
         <Domain name="input_type" id="374.Input.input_type">
           <DataType value="vtkDataSet"/>
         </Domain>
       </Property>
       <Property name="PieceInvariant" id="374.PieceInvariant" number_of_elements="1">
         <Element index="0" value="1"/>
         <Domain name="bool" id="374.PieceInvariant.bool"/>
       </Property>
     </Proxy>
     <Proxy group="filters" type="PlotOnSortedLines" id="971" servers="1" compound_name="PlotEdges1">
       <Property name="Input" id="971.Input" number_of_elements="1">
         <Proxy value="667" output_port="0"/>
         <Domain name="groups" id="971.Input.groups">
           <Group value="sources"/>
           <Group value="filters"/>
         </Domain>
         <Domain name="input_type" id="971.Input.input_type">
           <DataType value="vtkPolyData"/>
         </Domain>
       </Property>
     </Proxy>
     <Proxy group="filters" type="Cut" id="667" servers="1" compound_name="Slice1">
       <Property name="ContourValues" id="667.ContourValues" number_of_elements="1">
         <Element index="0" value="0"/>
         <Domain name="bounds" id="667.ContourValues.bounds">
           <Min index="0" value="-0.718069"/>
           <Max index="0" value="0.718069"/>
         </Domain>
       </Property>
       <Property name="CutFunction" id="667.CutFunction" number_of_elements="1">
         <Proxy value="670"/>
         <Domain name="groups" id="667.CutFunction.groups">
           <Group value="implicit_functions"/>
         </Domain>
         <Domain name="proxy_list" id="667.CutFunction.proxy_list">
           <Proxy value="670"/>
           <Proxy value="671"/>
           <Proxy value="672"/>
         </Domain>
       </Property>
       <Property name="Input" id="667.Input" number_of_elements="1">
         <Proxy value="374" output_port="0"/>
         <Domain name="groups" id="667.Input.groups">
           <Group value="sources"/>
           <Group value="filters"/>
         </Domain>
         <Domain name="input_type" id="667.Input.input_type">
           <DataType value="vtkDataSet"/>
         </Domain>
       </Property>
       <Property name="InputBounds" id="667.InputBounds">
         <Domain name="bounds" id="667.InputBounds.bounds">
           <Min index="0" value="-0.5"/>
           <Min index="1" value="-0.124991"/>
           <Min index="2" value="-0.5"/>
           <Max index="0" value="0.5"/>
           <Max index="1" value="0.124991"/>
           <Max index="2" value="0.5"/>
         </Domain>
       </Property>
     </Proxy>
     <Proxy group="implicit_functions" type="Plane" id="670" servers="1" compound_name="auto_670">
       <Property name="Normal" id="670.Normal" number_of_elements="3">
         <Element index="0" value="1"/>
         <Element index="1" value="0"/>
         <Element index="2" value="0"/>
         <Domain name="range" id="670.Normal.range"/>
       </Property>
       <Property name="Offset" id="670.Offset" number_of_elements="1">
         <Element index="0" value="0"/>
         <Domain name="range" id="670.Offset.range">
           <Min index="0" value="0"/>
           <Max index="0" value="0"/>
         </Domain>
       </Property>
       <Property name="Origin" id="670.Origin" number_of_elements="3">
         <Element index="0" value="0"/>
         <Element index="1" value="0"/>
         <Element index="2" value="0"/>
         <Domain name="range" id="670.Origin.range">
           <Min index="0" value="-0.5"/>
           <Min index="1" value="-0.124991"/>
           <Min index="2" value="-0.5"/>
           <Max index="0" value="0.5"/>
           <Max index="1" value="0.124991"/>
           <Max index="2" value="0.5"/>
         </Domain>
       </Property>
     </Proxy>
     <ExposedProperties>
       <Property name="Input" proxy_name="ExtractSurface1" exposed_name="Input"/>
       <Property name="CutFunction" proxy_name="Slice1" exposed_name="Slice Type"/>
     </ExposedProperties>
     <OutputPort name="Output" proxy="PlotEdges1" port_index="0"/>
     <Hints>
       <!-- View can be used to specify the preferred view for the proxy -->
       <View type="XYChartView" />
       <Plotable />
     </Hints>
   </CompoundSourceProxy>
   <!-- ==================================================================== -->
   <SourceProxy name="Subdivide" class="vtkLinearSubdivisionFilter">
    <Documentation
       long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
       short_help="Creates a surface with more triangles than the input.">
The Subdivide filter iteratively divides each triangle in the input dataset into 4 new triangles. Three new points are added per triangle -- one at the midpoint of each edge. This filter operates only on polygonal data containing triangles, so run your polygonal data through the Triangulate filter first if it is not composed of triangles. The output of this filter is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            This parameter specifies the input to the Subdivide filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="NumberOfSubdivisions"
        command="SetNumberOfSubdivisions"
        number_of_elements="1"
        default_values="1"
        label="Number of Subdivisions">
       <IntRangeDomain name="range" min="1" max="4"/>
       <Documentation>
         The value of this property specifies the number of subdivision iterations to perform.
       </Documentation>
     </IntVectorProperty>
   <!-- End Subdivide -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TessellatorFilter" class="vtkTessellatorFilter"
     label="Tessellate">
     <Documentation
        long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
        short_help="Polygonalize a mesh.">
The Tessellate filter tessellates cells with nonlinear geometry and/or scalar fields into a simplicial complex with linearly interpolated field values that more closely approximate the original field. This is useful for datasets containing quadratic cells.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
             <DataType value="vtkDataSet"/>
             <DataType value="vtkUnstructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Tessellate filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="OutputDimension"
        command="SetOutputDimension"
        number_of_elements="1"
        default_values="3">
       <IntRangeDomain name="range" min="1" max="3"/>
       <Documentation>
         The value of this property sets the maximum dimensionality of the output tessellation. When the value of this property is 3, 3D cells produce tetrahedra, 2D cells produce triangles, and 1D cells produce line segments. When the value is 2, 3D cells will have their boundaries tessellated with triangles. When the value is 1, all cells except points produce line segments.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="ChordError"
        command="SetChordError"
        number_of_elements="1"
        default_values="1e-3">
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property controls the maximum chord error allowed at any edge midpoint in the output tessellation. The chord error is measured as the distance between the midpoint of any output edge and the original nonlinear geometry.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="FieldError2"
        command="SetFieldCriterion"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        label="Field Error">
        <Documentation>
          This proeprty controls the maximum field error allowed at any edge midpoint in the output tessellation. The field error is measured as the difference between a field value at the midpoint of an output edge and the value of the corresponding field in the original nonlinear geometry.
        </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfSubdivisions"
        command="SetMaximumNumberOfSubdivisions"
        number_of_elements="1"
        default_values="3"
        label="Maximum Number of Subdivisions">
       <IntRangeDomain name="range" min="0" max="8"/>
       <Documentation>
         This property specifies the maximum number of times an edge may be subdivided. Increasing this number allows further refinement but can drastically increase the computational and storage requirements, especially when the value of the OutputDimension property is 3.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="MergePoints"
        command="SetMergePoints"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, coincident vertices will be merged after tessellation has occurred. Only geometry is considered during the merge and the first vertex encountered is the one whose point attributes will be used. Any discontinuities in point fields will be lost. On the other hand, many operations, such as streamline generation, require coincident vertices to be merged.
         Toggle whether to merge coincident vertices.
       </Documentation>
     </IntVectorProperty>

     <Property
        name="ResetFieldCriteria"
        command="ResetFieldCriteria"
        immediate_update="1">
     </Property>
   <!-- End TessellatorFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="DataSetTriangleFilter" class="vtkDataSetTriangleFilter"
     label="Tetrahedralize">
     <Documentation
        long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
        short_help="Convert to tetrahedrons and triangles.">
The Tetrahedralize filter converts the 3D cells of any type of dataset to tetrahedrons and the 2D ones to triangles. This filter always produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Tetrahedralize filter.
           </Documentation>
      </InputProperty>
   <!-- End DataSetTriangleFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TransformFilter" class="vtkTransformFilter"
    label="Transform">
    <Documentation
       long_help="This filter applies transformation to the polygons."
       short_help="Transform polygonal data.">
The Transform filter allows you to specify the position, size, and orientation of polygonal, unstructured grid, and curvilinear data sets.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPointSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Transform filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="Transform" command="SetTransform">
           <ProxyGroupDomain name="groups">
              <Group name="transforms"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="Transform3" />
           </ProxyListDomain>
           <Documentation>
             The values in this property allow you to specify the transform (translation, rotation, and scaling) to apply to the input dataset.
           </Documentation>
     </ProxyProperty>
   <!-- End TransformFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TriangleFilter" class="vtkTriangleFilter"
     label="Triangulate">
     <Documentation
        long_help="This filter converts polygons and triangle strips to basic triangles."
        short_help="Convert polygonal data to triangles.">
The Triangulate filter decomposes polygonal data into only triangles, points, and lines. It separates triangle strips and polylines into individual triangles and lines, respectively. The output is polygonal data. Some filters that take polygonal data as input require that the data be composed of triangles rather than other polygons, so passing your data through this filter first is useful in such situations. You should use this filter in these cases rather than the Tetrahedralize filter because they produce different output dataset types. The filters referenced require polygonal input, and the Tetrahedralize filter produces unstructured grid output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Triangulate filter.
           </Documentation>
      </InputProperty>
   <!-- End TriangleFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TubeFilter" class="vtkTubeFilter" label="Tube">
    <Documentation
       long_help="Convert lines into tubes. Normals are used to avoid cracks between tube segments."
       short_help="Convert lines into tubes.">
The Tube filter creates tubes around the lines in the input polygonal dataset. The output is also polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            This property specifies the input to the Tube filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars"
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the scalar array on which to
            operate. The indicated array may be used for scaling the tubes.
            (See the VaryRadius property.)
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Vectors">  <!-- default value=1 so normals go to the right place -->
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the vector array on which to
            operate. The indicated array may be used for scaling and/or
            orienting the tubes. (See the VaryRadius property.)
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfSides"
        command="SetNumberOfSides"
        number_of_elements="1"
        animateable="1"
        default_values="6"
        label="Number of Sides">
       <IntRangeDomain name="range" min="3"/>
       <Documentation>
         The value of this property indicates the number of faces around the circumference of the tube.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Capping"
        command="SetCapping"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, endcaps will be drawn on the tube. Otherwise the ends of the tube will be open.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="Radius"
         command="SetRadius"
         number_of_elements="1"
         default_values="1.0" >
        <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.01">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          The value of this property sets the radius of the tube. If the radius is varying (VaryRadius property), then this value is the minimum radius.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty
        name="VaryRadius"
        command="SetVaryRadius"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Off"/>
         <Entry value="1" text="By Scalar"/>
         <Entry value="2" text="By Vector"/>
         <Entry value="3" text="By Absolute Scalar"/>
       </EnumerationDomain>
       <Documentation>
         The property determines whether/how to vary the radius of the tube. If
         varying by scalar (1), the tube radius is based on the point-based
         scalar values in the dataset. If it is varied by vector, the vector
         magnitude is used in varying the radius.
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="RadiusFactor"
         command="SetRadiusFactor"
         number_of_elements="1"
         default_values="10" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If varying the radius (VaryRadius property), the property sets the
          maximum tube radius in terms of a multiple of the minimum radius. If
          not varying the radius, this value has no effect.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty
        name="UseDefaultNormal"
        command="SetUseDefaultNormal"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 0, and the input contains no vector array, then default ribbon normals will be generated (DefaultNormal property); if a vector array has been set (SelectInputVectors property), the ribbon normals will be set from the specified array. If this property is set to 1, the default normal (DefaultNormal property) will be used, regardless of whether the SelectInputVectors property has been set.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="DefaultNormal"
        command="SetDefaultNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The value of this property specifies the normal to use when the UseDefaultNormal property is set to 1 or the input contains no vector array (SelectInputVectors property).
       </Documentation>
     </DoubleVectorProperty>

   <!-- End TubeFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="WarpScalar" class="vtkWarpScalar" label="Warp By Scalar">
     <Documentation
        long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
        short_help="Warp point scalars into a spatial elevation plot.">
The Warp (scalar) filter translates the points of the input data set along a vector by a distance determined by the specified scalars. This filter operates on polygonal, curvilinear, and unstructured grid data sets containing single-component scalar arrays. Because it only changes the positions of the points, the output data set type is the same as that of the input. Any scalars in the input dataset are copied to the output, so the data can be colored by them.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="1"/>
           <Documentation>
             This property specifies the input to the Warp (scalar) filter.
           </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the scalar array by which to warp the dataset.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        animateable="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The scalar value at a given point is multiplied by the value of this property to determine the magnitude of the change vector for that point.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Normal"
        command="SetNormal"
        number_of_elements="3"
        default_values="0 0 1" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         The values of this property specify the direction along which to warp the dataset if any normals contained in the input dataset are not being used for this purpose. (See the UseNormal property.)
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="UseNormal"
        command="SetUseNormal"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If point normals are present in the dataset, the value of this property toggles whether to use a single normal value (value = 1) or the normals from the dataset (value = 0).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="XYPlane"
        command="SetXYPlane"
        number_of_elements="1"
        default_values="0"
        label="XY Plane">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the Z-coordinates from the input are considered to be the scalar values, and the displacement is along the Z axis. This is useful for creating carpet plots.
       </Documentation>
     </IntVectorProperty>
   <!-- End WarpScalar -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="WarpVector" class="vtkWarpVector" label="Warp By Vector">
     <Documentation
        long_help="This filter displaces point coordinates along a vector attribute. It is useful for showing mechanical deformation."
        short_help="Warp (displace) the geometry with a given vector field.">
The Warp (vector) filter translates the points of the input dataset using a specified vector array. The vector array chosen specifies a vector per point in the input. Each point is translated along its vector by a given scale factor. This filter operates on polygonal, curvilinear, and unstructured grid datasets. Because this filter only changes the positions of the points, the output dataset type is the same as that of the input.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPointSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array" attribute_type="point"
                             number_of_components="3"/>
           <Documentation>
             This property specifies the input to the Warp (vector) filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty
         name="SelectInputVectors"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Vectors">
            <ArrayListDomain name="array_list" attribute_type="Vectors">
              <RequiredProperties>
                 <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
            <Documentation>
              The value of this property contains the name of the vector array by which to warp the dataset's point coordinates.
            </Documentation>
      </StringVectorProperty>

      <DoubleVectorProperty
         name="ScaleFactor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Each component of the selected vector array will be multiplied by the value of this property before being used to compute new point coordinates.
        </Documentation>
      </DoubleVectorProperty>
   <!-- End WarpVector -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Cut" class="vtkCutter" label="Slice">
    <Documentation
       long_help="This filter slices a data set with a plane. Slicing is similar to a contour. It creates surfaces from volumes and lines from surfaces."
       short_help="Slice datasets with planes.">
This filter extracts the portion of the input dataset that lies along the specified plane. The Slice filter takes any type of dataset as input. The output of this filter is polygonal data.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Slice filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Slice Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             This property sets the parameters of the slice function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1"
        label="Slice Offset Values">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            The values in this property specify a list of current offset values. This can be used to create multiple slices with different centers. Each entry represents a new slice with its center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Cut -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractGeometry" class="vtkExtractGeometry"
                label="Extract Cells By Region">
    <Documentation
       long_help="This filter extracts cells that are inside/outside a region or at a region boundary."
       short_help="Extract cells that are inside/outside a region or at a region boundary.">
This filter extracts from its input dataset all cells that are either completely inside or outside of a specified region (implicit function). On output, the filter generates an unstructured grid.
To use this filter you must specify a region  (implicit function). You must also specify whethter to extract cells lying inside or outside of the region. An option exists to extract cells that are neither inside or outside (i.e., boundary).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Slice filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ImplicitFunction" command="SetImplicitFunction"
                    label="Intersect With">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             This property sets the region used to extract cells.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds" information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <IntVectorProperty
        label="Extraction Side"
        name="ExtractInside"
        command="SetExtractInside"
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="outside"/>
         <Entry value="1" text="inside"/>
       </EnumerationDomain>
       <Documentation>
This parameter controls whether to extract cells that are inside or outside the region.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Extract only intersected"
        command="SetExtractOnlyBoundaryCells"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
This parameter controls whether to extract only cells that are on the boundary of the region. If this parameter is set, the Extraction Side parameter is ignored. If Extract Intersected is off, this parameter has no effect.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Extract intersected"
        command="SetExtractBoundaryCells"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
This parameter controls whether to extract cells that are on the boundary of the region.
       </Documentation>
     </IntVectorProperty>

   <!-- End ExtractGeometry -->
    </SourceProxy>


   <!-- ==================================================================== -->
   <SourceProxy name="Clip" class="vtkPVClipDataSet">
    <Documentation
       long_help="Clip with an implicit plane. Clipping does not reduce the dimensionality of the data set. The output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane.">
The Clip filter cuts away a portion of the input data set using an implicit plane. This filter operates on all types of data sets, and it returns unstructured grid data on output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"
                            number_of_components="1" optional="1"/>
         <Documentation>
           This property specifies the dataset on which the Clip filter will operate.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              <Proxy group="implicit_functions" name="Scalar" />
           </ProxyListDomain>
           <Documentation>
             This property specifies the parameters of the clip function (an implicit plane) used to clip the dataset.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             If clipping with scalars, this property specifies the name of the scalar array on which to perform the clip operation.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <DoubleRangeDomain name="range"/>

          <Documentation>
            If clipping with scalars, this property sets the scalar value about which to clip the dataset based on the scalar array chosen. (See SelectInputScalars.) If clipping with a clip function, this property specifies an offset from the clip function to use in the clipping operation. Neither functionality is currently available in ParaView's user interface.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
         name="InsideOut"
         command="SetInsideOut"
         number_of_elements="1"
         default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 0, the clip filter will return that portion of the dataset that lies within the clip function. If set to 1, the portions of the dataset that lie outside the clip function will be returned instead.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseValueAsOffset"
        command="SetUseValueAsOffset"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
           If UseValueAsOffset is true, Value is used as an offset parameter to the implicit function. Otherwise, Value is used only when clipping using a scalar array.
        </Documentation>
     </IntVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
       <Property name="UseValueAsOffset" show="0"/>
     </Hints>
   <!-- End Clip -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ClipClosedSurface" class="vtkPVClipClosedSurface"
    label="Clip Closed Surface">
    <Documentation
       long_help="Clip a polygonal dataset with a plane to produce closed surfaces"
       short_help="Clip a polygonal dataset with a plane to produce closed surfaces">
This clip filter cuts away a portion of the input polygonal dataset using a plane to generate a new polygonal dataset.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
         <Documentation>
           This property specifies the dataset on which the Clip filter will operate.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClippingPlane" command="SetClippingPlane"
        label="Clipping Plane">

           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="implicit_functions" name="Plane" />
           </ProxyListDomain>

           <Documentation>
             This property specifies the parameters of the clipping plane used to clip the polygonal data.
           </Documentation>
     </ProxyProperty>

     <IntVectorProperty name="GenerateFaces"
       command="SetGenerateFaces"
       number_of_elements="1"
       default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Generate polygonal faces in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="GenerateOutline"
       command="SetGenerateOutline"
       number_of_elements="1"
       default_values="0">
       <BooleanDomain name="bool" />
       <Documentation>
         Generate clipping outlines in the output wherever an input face is cut by the clipping plane.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="GenerateColorScalars"
       label="Generate Cell Origins"
       command="SetGenerateColorScalars"
       number_of_elements="1"
       default_values="0">
       <BooleanDomain name="bool" />
       <Documentation>
         Generate (cell) data for coloring purposes such that the newly generated cells (including capping faces and clipping outlines) can be distinguished from the input cells.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
         name="InsideOut"
         command="SetInsideOut"
         number_of_elements="1"
         default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
           If this flag is turned off, the clipper will return the portion of the data that lies within the clipping plane. Otherwise, the clipper will return the portion of the data that lies outside the clipping plane.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="Tolerance"
       label="Clipping Tolerance"
       command="SetTolerance"
       number_of_elements="1"
       default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the tolerance for creating new points. A small value might incur degenerate triangles.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty name="BaseColor" command="SetBaseColor"
       label="Base Color"
       number_of_elements="3"
       default_values="0.10 0.10 1.00">
       <DoubleRangeDomain name="range" min="0 0 0" max="1 1 1"/>
       <Documentation>
         Specify the color for the faces from the input.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty name="ClipColor" command="SetClipColor"
       label="Clip Color"
       number_of_elements="3"
       default_values="1.00 0.11 0.10">
       <DoubleRangeDomain name="range" min="0 0 0" max="1 1 1"/>
       <Documentation>
         Specifiy the color for the capping faces (generated on the clipping interface).
       </Documentation>
     </DoubleVectorProperty>

   <!-- End Clip -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Threshold" class="vtkThreshold">
    <Documentation
       long_help="This filter extracts cells that have point or cell scalars in the specified range."
       short_help="Extract cells that satisfy a threshold criterion.">
The Threshold filter extracts the portions of the input dataset whose scalars lie within the specified range. This filter operates on either point-centered or cell-centered data. This filter operates on any type of dataset and produces unstructured grid output.

To select between these two options, select either Point Data or Cell Data from the Attribute Mode menu. Once the Attribute Mode has been selected, choose the scalar array from which to threshold the data from the Scalars menu. The Lower Threshold and Upper Threshold sliders determine the range of the scalars to retain in the output. The All Scalars check box only takes effect when the Attribute Mode is set to Point Data. If the All Scalars option is checked, then a cell will only be passed to the output if the scalar values of all of its points lie within the range indicated by the Lower Threshold and Upper Threshold sliders. If unchecked, then a cell will be added to the output if the specified scalar value for any of its points is within the chosen range.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
             <RequiredProperties>
                <Property name="SelectInputScalars"
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            This property specifies the input to the Threshold filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
           <ArrayListDomain name="array_list"
                            attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             The value of this property contains the name of the scalar array from which to perform thresholding.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ThresholdBetween"
        command="ThresholdBetween"
        number_of_elements="2"
        default_values="0 0"
        label="Threshold Range">
          <ArrayRangeDomain name="range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            The values of this property specify the upper and lower bounds of the thresholding operation.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="AllScalars"
        command="SetAllScalars"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then a cell is only included in the output if the value of the selected array for all its points is within the threshold. This is only relevant when thresholding by a point-centered array.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Threshold -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="IsoVolume" class="vtkIsoVolume" label="Iso Volume">
    <Documentation
       long_help="This filter extracts cells by clipping cells that have point
       scalars not in the specified range."
       short_help="Extract cells that satisfy a threshold criterion.">
       This filter clip away the cells using lower and upper thresholds.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" number_of_components="1">
             <RequiredProperties>
                <Property name="SelectInputScalars"
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            This property specifies the input to the Threshold filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Input Scalars">
           <ArrayListDomain name="array_list"
                            attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             The value of this property contains the name of the scalar array from which to perform thresholding.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ThresholdBetween"
        command="ThresholdBetween"
        number_of_elements="2"
        default_values="0 0"
        label="Threshold Range">
          <ArrayRangeDomain name="range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            The values of this property specify the upper and lower bounds of the thresholding operation.
          </Documentation>
     </DoubleVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End Iso Volume -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Contour" class="vtkPVContourFilter">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The Contour filter operates on any type of data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"
                            number_of_components="1"
                            attribute_type="point"/>
          <Documentation>
            This property specifies the input dataset to be used by the contour filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Contour By">
          <ArrayListDomain name="array_list" attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
          <Documentation>
            This property specifies the name of the scalar array from which the contour filter will compute isolines and/or isosurfaces.
          </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        label="Isosurfaces"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            This property specifies the values at which to compute isosurfaces/isolines and also the number of such values.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="ComputeNormals"
        command="SetComputeNormals"
        number_of_elements="1"
        default_values="1"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, a scalar array containing a normal value at each point in the isosurface or isoline will be created by the contour filter; otherwise an array of normals will not be computed. This operation is fairly expensive both in terms of computation time and memory required, so if the output dataset produced by the contour filter will be processed by filters that modify the dataset's topology or geometry, it may be wise to set the value of this property to 0.
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeGradients"
        command="SetComputeGradients"
        number_of_elements="1"
        default_values="0"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, a scalar array containing a gradient value at each point in the isosurface or isoline will be created by this filter; otherwise an array of gradients will not be computed. This operation is fairly expensive both in terms of computation time and memory required, so if the output dataset produced by the contour filter will be processed by filters that modify the dataset's topology or geometry, it may be wise to set the value of this property to 0. Not that if ComputeNormals is set to 1, then gradients will have to be calculated, but they will only be stored in the output dataset if ComputeGradients is also set to 1.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeScalars"
        command="SetComputeScalars"
        number_of_elements="1"
        default_values="0"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, an array of scalars (containing the contour value) will be added to the output dataset. If set to 0, the output will not contain this array.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>

     <!-- incremental point locator begin -->
     <ProxyProperty name="Locator" command="SetLocator"
       label="Point Merge Method">
       <ProxyGroupDomain name="groups">
         <Group name="incremental_point_locators" />
       </ProxyGroupDomain>
       <ProxyListDomain name="proxy_list">
         <Proxy group="incremental_point_locators" name="MergePoints" />
         <Proxy group="incremental_point_locators" name="IncrementalOctreeMergePoints" />
         <Proxy group="incremental_point_locators" name="NonMergingPointLocator" />
       </ProxyListDomain>
       <Documentation>
         This property specifies an incremental point locator for merging duplicate / coincident points.
       </Documentation>
     </ProxyProperty>
     <!-- incremental point locator end -->
   <!-- End Contour -->
   </SourceProxy>


   <!-- ==================================================================== -->
   <SourceProxy name="Glyph" class="vtkPVGlyphFilter">
    <Documentation
       long_help="This filter generates an arrow, cone, cube, cylinder, line, sphere, or 2D glyph at each point of the input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, cube, cylinder, line, sphere, or 2D glyph) at each point in the input dataset. The glyphs can be oriented and scaled by the input point-centered scalars and vectors. The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            This property specifies the input to the Glyph filter. This is the dataset to which the glyphs will be applied.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars"
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the scalar array on which to operate. The indicated array may be used for scaling the glyphs. (See the SetScaleMode property.)
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Vectors">  <!-- default value=1 so normals go to the right place -->
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the vector array on which to operate. The indicated array may be used for scaling and/or orienting the glyphs. (See the SetScaleMode and SetOrient properties.)
          </Documentation>
     </StringVectorProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="sources" name="ArrowSource" />
              <Proxy group="sources" name="ConeSource" />
              <Proxy group="sources" name="CubeSource" />
              <Proxy group="sources" name="CylinderSource" />
              <Proxy group="sources" name="LineSource" />
              <Proxy group="sources" name="SphereSource" />
              <Proxy group="sources" name="GlyphSource2D" />
           </ProxyListDomain>
           <Documentation>
             This property determines which type of glyph will be placed at the points in the input dataset.
           </Documentation>
     </InputProperty>

     <ProxyProperty name="GlyphTransform" command="SetSourceTransform">
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="Transform2" />
           </ProxyListDomain>
           <Documentation>
             The values in this property allow you to specify the transform
             (translation, rotation, and scaling) to apply to the glyph source.
           </Documentation>
     </ProxyProperty>

     <IntVectorProperty
        label="Orient"
        name="SetOrient"
        command="SetOrient"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the glyphs will be oriented based on the selected vector array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        label="Scale Mode"
        name="SetScaleMode"
        command="SetScaleMode"
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property specifies how/if the glyphs should be scaled based on the point-centered scalars/vectors in the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <Documentation>
         The value of this property will be used as a multiplier for scaling the glyphs before adding them to the output.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfPoints"
        command="SetMaximumNumberOfPoints"
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property specifies the maximum number of glyphs that should appear in the output dataset if the value of the UseMaskPoints property is 1. (See the UseMaskPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseMaskPoints"
        command="SetUseMaskPoints"
        number_of_elements="1"
        default_values="1"
        label="Mask Points">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, limit the maximum number of glyphs to the value indicated by MaximumNumberOfPoints. (See the MaximumNumberOfPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="RandomMode"
        command="SetRandomMode"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the points to glyph are chosen randomly. Otherwise the point ids chosen are evenly spaced.
       </Documentation>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ArbitrarySourceGlyph" class="vtkPVGlyphFilter"
    label="Glyph With Custom Source">
    <Documentation
       long_help="This filter generates a glyph at each point of the input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
       short_help="Generate a glyph symbol at each point of the input data set.">
The Glyph filter generates a glyph at each point in the input dataset. The glyphs can be oriented and scaled by the input point-centered scalars and vectors. The Glyph filter operates on any type of data set. Its output is polygonal. This filter is available on the Toolbar.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array1" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <InputArrayDomain name="input_array2" attribute_type="point"
                            number_of_components="3" optional="1"/>
          <Documentation>
            This property specifies the input to the Glyph filter. This is the dataset to which the glyphs will be applied.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="glyph_sources" />
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property determines which type of glyph will be placed at the points in the input dataset.
           </Documentation>
      </InputProperty>


     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
          <ArrayListDomain name="array_list" attribute_type="Scalars"
               input_domain_name="input_array1">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the scalar array on which to operate. The indicated array may be used for scaling the glyphs. (See the SetScaleMode property.)
          </Documentation>
     </StringVectorProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Vectors">  <!-- default value=1 so normals go to the right place -->
          <ArrayListDomain name="array_list" attribute_type="Vectors"
               input_domain_name="input_array2">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property indicates the name of the vector array on which to operate. The indicated array may be used for scaling and/or orienting the glyphs. (See the SetScaleMode and SetOrient properties.)
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        label="Orient"
        name="SetOrient"
        command="SetOrient"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1, the glyphs will be oriented based on the selected vector array.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        label="Scale Mode"
        name="SetScaleMode"
        command="SetScaleMode"
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="scalar"/>
         <Entry value="1" text="vector"/>
         <Entry value="2" text="vector_components"/>
         <Entry value="3" text="off"/>
       </EnumerationDomain>
       <Documentation>
         The value of this property specifies how/if the glyphs should be scaled based on the point-centered scalars/vectors in the input dataset.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="SetScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="0.1">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <ArrayRangeDomain name="vector_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputVectors" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
       <Documentation>
         The value of this property will be used as a multiplier for scaling the glyphs before adding them to the output.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfPoints"
        command="SetMaximumNumberOfPoints"
        number_of_elements="1"
        default_values="5000"
        label="Maximum Number of Points">
       <IntRangeDomain name="range" min="0"/>
       <Documentation>
         The value of this property specifies the maximum number of glyphs that should appear in the output dataset if the value of the UseMaskPoints property is 1. (See the UseMaskPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="UseMaskPoints"
        command="SetUseMaskPoints"
        number_of_elements="1"
        default_values="1"
        label="Mask Points">
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is set to 1, limit the maximum number of glyphs to the value indicated by MaximumNumberOfPoints. (See the MaximumNumberOfPoints property.)
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="RandomMode"
        command="SetRandomMode"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then the points to glyph are chosen randomly. Otherwise the point ids chosen are evenly spaced.
       </Documentation>
     </IntVectorProperty>
   <Hints>
     <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
          replace_input="1" implies always replace input.
          replace_input="2" implies replace input only when input is shown as a
                            solid i.e surface or surface with edges.
       -->
     <Visibility replace_input="0" />
   </Hints>
   <!-- End Glyph -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractGrid" class="vtkPVExtractVOI"
    label="Extract Subset">
    <Documentation
       long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
       short_help="Extract a subgrid or subsample.">
The Extract Grid filter returns a subgrid of a structured input data set (uniform rectilinear, curvilinear, or nonuniform rectilinear). The output data set type of this filter is the same as the input type.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkImageData"/>
            <DataType value="vtkRectilinearGrid"/>
            <DataType value="vtkStructuredPoints"/>
            <DataType value="vtkStructuredGrid"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the Extract Grid filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="VOI"
        command="SetVOI"
        number_of_elements="6"
        default_values="0 0 0 0 0 0">
       <ExtentDomain name="extent">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ExtentDomain>
       <Documentation>
         This property specifies the minimum and maximum point indices along each of the I, J, and K axes; these values indicate the volume of interest (VOI). The output will have the (I,J,K) extent specified here.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="SampleRateI"
        command="SetSampleRateI"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the I dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="SampleRateJ"
        command="SetSampleRateJ"
        animateable="1"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the J dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="SampleRateK"
        animateable="1"
        command="SetSampleRateK"
        number_of_elements="1" default_values="1">
       <IntRangeDomain name="range" min="1"/>
       <Documentation>
         This property indicates the sampling rate in the K dimension. A value grater than 1 results in subsampling; every nth index will be included in the output.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="IncludeBoundary"
        command="SetIncludeBoundary"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then if the sample rate in any dimension is greater than 1, the boundary indices of the input dataset will be passed to the output even if the boundary extent is not an even multiple of the sample rate in a given dimension.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End ExtractGrid -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ProbePoint" class="vtkPProbeFilter"
    label="Probe Location">
    <Documentation
       long_help="Sample data attributes at the points in a point cloud."
       short_help="Sample data values at the points in a point cloud.">
The Probe filter samples the data set attributes of the current data set at the points in a point cloud. The Probe filter uses interpolation to determine the values at the selected point, whether or not it lies at an input point. The Probe filter operates on any type of data and produces polygonal output (a point cloud).
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkCompositeDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection"
        label="Probe Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
             <Proxy group="extended_sources" name="FixedRadiusPointSource" />
           </ProxyListDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End ProbePoint -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <CompoundSourceProxy name="ProbeLine" label="Plot Over Line">
     <Documentation
       long_help="Sample data attributes at the points along a line.  Probed lines will be displayed in a graph of the attributes."
       short_help="Sample data values at the points along a line.">
        The Plot Over Line filter samples the data set attributes of the current
        data set at the points along a line. The values of the point-centered variables
        along that line will be displayed in an XY Plot. This filter uses interpolation
        to determine the values at the selected point, whether or not it lies at an
        input point. The Probe filter operates on any type of data and produces
        polygonal output (a line).
     </Documentation>
     <Proxy group="internal_filters" type="ProbeLine" id="491" servers="1"
            compound_name="PlotOverLine1" />
     <Proxy group="internal_filters" type="AppendArcLength" id="588" servers="1" compound_name="AppendArcLength1">
       <Property name="Input" id="588.Input" number_of_elements="1">
         <Proxy value="491" output_port="0"/>
       </Property>
     </Proxy>
     <ExposedProperties>
       <Property name="Input" proxy_name="PlotOverLine1" exposed_name="Input"/>
       <Property name="Source" proxy_name="PlotOverLine1" exposed_name="Source"/>
       <Property name="PassPartialArrays"
          proxy_name="PlotOverLine1" exposed_name="PassPartialArrays"/>
     </ExposedProperties>
     <OutputPort name="Output" proxy="AppendArcLength1" port_index="0"/>
     <Hints>
       <Visibility replace_input="0" />
       <!-- View can be used to specify the preferred view for the proxy -->
      <View type="XYChartView" />
      <Plotable />
     </Hints>
    <!-- End ProbeLine -->
   </CompoundSourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="Probe" class="vtkPProbeFilter"
    label="Resample With Dataset">
    <Documentation
       long_help="Sample data attributes at the points of a dataset."
       short_help="Sample data values at the points of a dataset.">
Probe is a filter that computes point attributes at specified point positions. The filter has two inputs: the Input and Source. The Input geometric structure is passed through the filter. The point attributes are computed at the Input point positions by interpolating into the source data. For example, we can compute data values on a plane (plane specified as Input) from a volume (Source). The cell data of the source data is copied to the output based on in which source cell each input point is. If an array of the same name exists both in source's point and cell data, only the one from the point data is probed.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetSourceConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkCompositeDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array"/>
          <Documentation>
            This property specifies the dataset from which to obtain probe values.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
           <Documentation>
             This property specifies the dataset whose geometry will be used in determining positions to probe.
           </Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
   <!-- End Probe -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="StreamTracer" class="vtkDistributedStreamTracer"
    label="Stream Tracer">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. Production of streamlines terminates if a streamline crosses the exterior boundary of the input dataset. Other reasons for termination are listed for the MaximumNumberOfSteps, TerminalSpeed, and MaximumPropagation properties. This filter operates on any type of dataset, provided it has point-centered vectors. The output is polygonal data containing polylines.
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            This property specifies the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="PointSource" />
              <Proxy group="extended_sources" name="HighResLineSource" />
           </ProxyListDomain>
           <Documentation>
             The value of this property determines how the seeds for the streamlines will be generated.
           </Documentation>
      </InputProperty>

     <StringVectorProperty
       name="SelectInputVectors"
       command="SetInputArrayToProcess"
       number_of_elements="5"
       element_types="0 0 0 0 2"
       animateable="0"
       label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
       name="NumberOfPoints"
       number_of_elements="1"
       default_values="100"
       information_only="1"/>

     <IntVectorProperty
       name="InterpolatorType"
       command="SetInterpolatorType"
       number_of_elements="1"
       default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Interpolator with Point Locator"/>
         <Entry value="1" text="Interpolator with Cell Locator"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which interpolator to use for evaluating the velocity vector field. The first is faster though the second is more robust in locating cells during streamline integration.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
       name="IntegrationDirection"
       command="SetIntegrationDirection"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         This property determines in which direction(s) a streamline is generated.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
       name="IntegratorType"
       command="SetIntegratorType"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which integrator (with increasing accuracy) to use for creating streamlines.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
       name="IntegrationStepUnit"
       label="Integration Step Unit"
       command="SetIntegrationStepUnit"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
           This property specifies the unit for Minimum/Initial/Maximum integration step size. The Length unit refers to the arc length that a particle travels/advects within a single step. The Cell Length unit represents the step size as a number of cells.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="InitialIntegrationStep"
       label="Initial Step Length"
       command="SetInitialIntegrationStep"
       number_of_elements="1"
       default_values="0.2" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the initial integration step size. For non-adaptive integrators (Runge-Kutta 2 and Runge-Kutta 4), it is fixed (always equal to this initial value) throughout the integration. For an adaptive integrator (Runge-Kutta 4-5), the actual step size varies such that the numerical error is less than a specified threshold.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MinimumIntegrationStep"
       label="Minimum Step Length"
       command="SetMinimumIntegrationStep"
       number_of_elements="1"
       default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         When using the Runge-Kutta 4-5 ingrator, this property specifies the minimum integration step size.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaximumIntegrationStep"
       label="Maximum Step Length"
       command="SetMaximumIntegrationStep"
       number_of_elements="1"
       default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         When using the Runge-Kutta 4-5 ingrator, this property specifies the maximum integration step size.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
       name="MaximumNumberOfSteps"
       label="Maximum Steps"
       command="SetMaximumNumberOfSteps"
       number_of_elements="1"
       default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum number of steps, beyond which streamline integration is terminated.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="MaximumPropagation"
       label="Maximum Streamline Length"
       command="SetMaximumPropagation"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         This property specifies the maximum streamline length (i.e., physical arc length), beyond which line integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="TerminalSpeed"
       label="Terminal Speed"
       command="SetTerminalSpeed"
       number_of_elements="1"
       default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the terminal speed, below which particle advection/integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaximumError"
       command="SetMaximumError"
       number_of_elements="1"
       default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum error (for Runge-Kutta 4-5) tolerated throughout streamline integration. The Runge-Kutta 4-5 integrator tries to adjust the step size such that the estimated error is less than this threshold.
       </Documentation>
     </DoubleVectorProperty>

      <IntVectorProperty
         name="ComputeVorticity"
         command="SetComputeVorticity"
         number_of_elements="1"
         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Specify whether or not to compute vorticity.
        </Documentation>
      </IntVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ArbitrarySourceStreamTracer" class="vtkDistributedStreamTracer"
    label="Stream Tracer With Custom Source">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Stream Tracer filter generates streamlines in a vector field from a collection of seed points. Production of streamlines terminates if a streamline crosses the exterior boundary of the input dataset. Other reasons for termination are listed for the MaximumNumberOfSteps, TerminalSpeed, and MaximumPropagation properties. This filter operates on any type of dataset, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter takes a Source input that provides the seed points.
    </Documentation>
    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type" composite_data_supported="1">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            This property specifies the input to the Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection" >
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <Documentation>
              This property specifies the input used to obtain the seed points.
           </Documentation>
      </InputProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="NumberOfPoints"
        number_of_elements="1"
        default_values="100"
        information_only="1"/>

     <IntVectorProperty
       name="IntegrationDirection"
       command="SetIntegrationDirection"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         This property determines in which direction(s) a streamline is generated.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
       name="IntegratorType"
       command="SetIntegratorType"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which integrator (with increasing accuracy) to use for creating streamlines.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
       name="IntegrationStepUnit"
       label="Integration Step Unit"
       command="SetIntegrationStepUnit"
       number_of_elements="1"
       default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
           This property specifies the unit for Minimum/Initial/Maximum integration step size. The Length unit refers to the arc length that a particle travels/advects within a single step. The Cell Length unit represents the step size as a number of cells.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="InitialIntegrationStep"
       label="Initial Step Length"
       command="SetInitialIntegrationStep"
       number_of_elements="1"
       default_values="0.2" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the initial integration step size. For non-adaptive integrators (Runge-Kutta 2 and Runge-Kutta 4), it is fixed (always equal to this initial value) throughout the integration. For an adaptive integrator (Runge-Kutta 4-5), the actual step size varies such that the numerical error is less than a specified threshold.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MinimumIntegrationStep"
       label="Minimum Step Length"
       command="SetMinimumIntegrationStep"
       number_of_elements="1"
       default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         When using the Runge-Kutta 4-5 ingrator, this property specifies the minimum integration step size.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaximumIntegrationStep"
       label="Maximum Step Length"
       command="SetMaximumIntegrationStep"
       number_of_elements="1"
       default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         When using the Runge-Kutta 4-5 ingrator, this property specifies the maximum integration step size.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
       name="MaximumNumberOfSteps"
       label="Maximum Steps"
       command="SetMaximumNumberOfSteps"
       number_of_elements="1"
       default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum number of steps, beyond which streamline integration is terminated.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
       name="MaximumPropagation"
       label="Maximum Streamline Length"
       command="SetMaximumPropagation"
       number_of_elements="1"
       default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         This property specifies the maximum streamline length (i.e., physical arc length), beyond which line integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="TerminalSpeed"
       label="Terminal Speed"
       command="SetTerminalSpeed"
       number_of_elements="1"
       default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the terminal speed, below which particle advection/integration is terminated.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
       name="MaximumError"
       command="SetMaximumError"
       number_of_elements="1"
       default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         This property specifies the maximum error (for Runge-Kutta 4-5) tolerated throughout streamline integration. The Runge-Kutta 4-5 integrator tries to adjust the step size such that the estimated error is less than this threshold.
       </Documentation>
     </DoubleVectorProperty>

      <IntVectorProperty
         name="ComputeVorticity"
         command="SetComputeVorticity"
         number_of_elements="1"
         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Specify whether or not to compute vorticity.
        </Documentation>
      </IntVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End StreamTracer -->
   </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="TemporalCache" class="vtkTemporalDataSetCache"
                 label="Temporal Cache">
      <Documentation short_help="Caches data per time step."
                     long_help="Saves a copy of the data set for a fixed number of time steps.">
        The Temporal Cache can be used to save multiple copies of a data set at different time steps to prevent thrashing in the pipeline caused by downstream filters that adjust the requested time step.  For example, assume that there is a downstream Temporal Interpolator filter.  This filter will (usually) request two time steps from the upstream filters, which in turn (usually) causes the upstream filters to run twice, once for each time step.  The next time the interpolator requests the same two time steps, they might force the upstream filters to re-evaluate the same two time steps.  The Temporal Cache can keep copies of both of these time steps and provide the requested data without having to run upstream filters.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
       <DataTypeDomain name="input_type" composite_data_supported="1">
         <DataType value="vtkDataObject"/>
       </DataTypeDomain>
        <Documentation>
          This property specifies the input of the Temporal Cache filter.
        </Documentation>
      </InputProperty>

      <IntVectorProperty
         name="CacheSize"
         command="SetCacheSize"
         number_of_elements="1"
         default_values="2" >
        <IntRangeDomain name="range" min="2" max="10"/>
        <Documentation>
          The cache size determines the number of time steps that can be cached at one time.  The maximum number is 10.  The minimum is 2 (since it makes little sense to cache less than that).
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalCache -->
    </SourceProxy>

    <SourceProxy name="TemporalInterpolator" class="vtkTemporalInterpolator"
                 label="Temporal Interpolator">
      <Documentation short_help="Interpolate between time steps."
                     long_help="Interpolate between time steps.">
        The Temporal Interpolator converts data that is defined at discrete time steps to one that is defined over a continuum of time by linearly interpolating the data's field data between two adjacent time steps.  The interpolated values are a simple approximation and should not be interpreted as anything more.  The Temporal Interpolator assumes that the topology between adjacent time steps does not change.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type" composite_data_supported="1">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input of the Temporal Interpolator.
        </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="DiscreteTimeStepInterval"
         command="SetDiscreteTimeStepInterval"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If Discrete Time Step Interval is set to 0, then the Temporal Interpolator will provide a continuous region of time on its output.  If set to anything else, then the output will define a finite set of time points on its output, each spaced by the Discrete Time Step Interval.  The output will have (time range)/(discrete time step interval) time steps.  (Note that the time range is defined by the time range of the data of the input filter, which may be different from other pipeline objects or the range defined in the animation inspector.)  This is a useful option to use if you have a dataset with one missing time step and wish to 'file-in' the missing data with an interpolated value from the steps on either side.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

     <DoubleVectorProperty name="TimeRange"
        information_only="1">
       <TimeRangeInformationHelper/>
     </DoubleVectorProperty>

      <!-- End TemporalInterpolator -->
    </SourceProxy>

    <SourceProxy name="TemporalSnapToTimeStep"
                 class="vtkTemporalSnapToTimeStep"
                 label="Temporal Snap-to-Time-Step">
      <Documentation
        short_help="Modifies the time range/steps of temporal data."
        long_help="Modifies the time range/steps of temporal data." >
        This file modifies the time range or time steps of
        the data without changing the data itself. The data is not resampled
        by this filter, only the information accompanying the data is modified.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
       <DataTypeDomain name="input_type" composite_data_supported="1">
         <DataType value="vtkDataObject"/>
       </DataTypeDomain>
       <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>

      <IntVectorProperty
         name="SnapMode"
         command="SetSnapMode"
         number_of_elements="1"
         default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="Nearest"/>
          <Entry value="1" text="NextBelowOrEqual"/>
          <Entry value="2" text="NextAboveOrEqual"/>
        </EnumerationDomain>
        <Documentation>
          Determine which time step to snap to.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalSnapToTimeStep -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="TemporalShiftScale" class="vtkTemporalShiftScale"
                 label="Temporal Shift Scale">
      <Documentation short_help="Shift and scale time values."
                     long_help="Shift and scale time values.">
        The Temporal Shift Scale filter linearly transforms the time values of a pipeline object by applying a shift and then scale.  Given a data at time t on the input, it will be transformed to time t*Shift + Scale on the output.  Inversely, if this filter has a request for time t, it will request time (t-Shift)/Scale on its input.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type" composite_data_supported="1">
          <DataType value="vtkDataObject"/>
        </DataTypeDomain>
        <Documentation>
          The input to the Temporal Shift Scale filter.
        </Documentation>
      </InputProperty>

      <DoubleVectorProperty
         name="PreShift"
         command="SetPreShift"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Apply a translation to the data before scaling.
          To convert T{5,100} to T{0,1} use Preshift=-5, Scale=1/95, PostShift=0
          To convert T{5,105} to T{5,10} use Preshift=-5, Scale=5/100, PostShift=5
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="PostShift"
         command="SetPostShift"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The amount of time the input is shifted.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Scale"
         command="SetScale"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The factor by which the input time is scaled.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="Periodic"
         command="SetPeriodic"
         number_of_elements="1"
         default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If Periodic is true, requests for time will be wrapped around so that
          the source appears to be a periodic time source. If data exists for times
          {0,N-1}, setting periodic to true will cause time 0 to be produced when time
          N, 2N, 2N etc is requested. This effectively gives the source the ability to
          generate time data indefinitely in a loop.
          When combined with Shift/Scale, the time becomes periodic in the
          shifted and scaled time frame of reference.
          Note: Since the input time may not start at zero, the wrapping of time
          from the end of one period to the start of the next, will subtract the
          initial time - a source with T{5..6} repeated periodicaly will have output
          time {5..6..7..8} etc.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="PeriodicEndCorrection"
         command="SetPeriodicEndCorrection"
         number_of_elements="1"
         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          If Periodic time is enabled, this flag determines if the last time step is the same
          as the first. If PeriodicEndCorrection is true, then it is assumed that the input
          data goes from 0-1 (or whatever scaled/shifted actual time) and time 1 is the
          same as time 0 so that steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where step N
          is the same as 0 and step 0 is not repeated. When this flag is false
          the data is assumed to be literal and output is of the form 0,1,2,3...N,0,1,2,3...
          By default this flag is ON
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="MaximumNumberOfPeriods"
         command="SetMaximumNumberOfPeriods"
         number_of_elements="1"
         default_values="1.0">
        <DoubleRangeDomain name="range" min="0" max="100" />
        <Documentation>
          If Periodic time is enabled, this controls how many time periods time is reported
          for. A filter cannot output an infinite number of time steps and therefore a finite
          number of periods is generated when reporting time.
      </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="TimestepValues"
         information_only="1">
        <TimeStepsInformationHelper/>
      </DoubleVectorProperty>

      <!-- End TemporalShiftScale -->
    </SourceProxy>

   <!-- ==================================================================== -->
     <SourceProxy name="TemporalStatistics" class="vtkTemporalStatistics"
                  label="Temporal Statistics">
       <Documentation short_help="Compute Temporal Statistics"
                      long_help="Loads in all time steps of a data set and computes some statistics about how each point and cell variable changes over time.">
         Given an input that changes over time, vtkTemporalStatistics looks
         at the data for each time step and computes some statistical
         information of how a point or cell variable changes over time.  For
         example, vtkTemporalStatistics can compute the average value of
         "pressure" over time of each point.

         Note that this filter will require the upstream filter to be run on
         every time step that it reports that it can compute.  This may be a
         time consuming operation.

         vtkTemporalStatistics ignores the temporal spacing.  Each timestep
         will be weighted the same regardless of how long of an interval it
         is to the next timestep.  Thus, the average statistic may be quite
         different from an integration of the variable if the time spacing
         varies.
       </Documentation>

       <InputProperty name="Input" command="SetInputConnection">
         <ProxyGroupDomain name="groups">
           <Group name="sources" />
           <Group name="filters" />
         </ProxyGroupDomain>
         <DataTypeDomain name="input_type">
           <DataType value="vtkDataSet" />
         </DataTypeDomain>
         <Documentation>
           Set the input to the Temporal Statistics filter.
         </Documentation>
       </InputProperty>

       <IntVectorProperty name="ComputeAverage"
                          command="SetComputeAverage"
                          number_of_elements="1"
                          default_values="1">
         <BooleanDomain name="bool" />
         <Documentation>
           Compute the average of each point and cell variable over time.
         </Documentation>
       </IntVectorProperty>

       <IntVectorProperty name="ComputeMinimum"
                          command="SetComputeMinimum"
                          number_of_elements="1"
                          default_values="1">
         <BooleanDomain name="bool" />
         <Documentation>
           Compute the minimum of each point and cell variable over time.
         </Documentation>
       </IntVectorProperty>

       <IntVectorProperty name="ComputeMaximum"
                          command="SetComputeMaximum"
                          number_of_elements="1"
                          default_values="1">
         <BooleanDomain name="bool" />
         <Documentation>
           Compute the maximum of each point and cell variable over time.
         </Documentation>
       </IntVectorProperty>

       <IntVectorProperty name="ComputeStandardDeviation"
                          command="SetComputeStandardDeviation"
                          number_of_elements="1"
                          default_values="1">
         <BooleanDomain name="bool" />
         <Documentation>
           Compute the standard deviation of each point and cell variable over time.
         </Documentation>
       </IntVectorProperty>

       <!-- End TemporalStatistics -->
     </SourceProxy>

   <!-- ==================================================================== -->

    <SourceProxy name="ParticlePathLines"
              class="vtkTemporalPathLineFilter"
              label="Particle Pathlines">
      <Documentation
         long_help="Creates polylines representing pathlines of animating particles"
         short_help="Particle Pathlines">
        Particle Pathlines takes any dataset as input, it extracts the
        point locations of all cells over time to build up a polyline
        trail.  The point number (index) is used as the 'key' if the points
        are randomly changing their respective order in the points list,
        then you should specify a scalar that represents the unique
        ID. This is intended to handle the output of a filter such as the
        TemporalStreamTracer.
      </Documentation>

      <OutputPort name="Pathlines" index="0" />
      <OutputPort name="Particles" index="1" />

      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" attribute_type="point"
                          optional="1"/>
        <Documentation>
          The input cells to create pathlines for.
        </Documentation>
      </InputProperty>

      <InputProperty
         name="Selection"
         command="SetSelectionConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Hints>
          <Optional />
        </Hints>
        <Documentation>
          Set a second input, which is a selection. Particles with the same
          Id in the selection as the primary input will be chosen for
          pathlines Note that you must have the same IdChannelArray in the
          selection as the input
        </Documentation>
      </InputProperty>

      <IntVectorProperty
          name="MaskPoints"
          command="SetMaskPoints"
          number_of_elements="1"
          default_values="100" >
        <Documentation>
          Set the number of particles to track as a ratio of the input.
          Example: setting MaskPoints to 10 will track every 10th point.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
          name="MaxTrackLength"
          command="SetMaxTrackLength"
          number_of_elements="1"
          default_values="25" >
        <Documentation>
          If the Particles being traced animate for a long time, the trails
          or traces will become long and stringy. Setting the
          MaxTraceTimeLength will limit how much of the trace is
          displayed. Tracks longer then the Max will disappear and the
          trace will apppear like a snake of fixed length which progresses
          as the particle moves.  This length is given with respect to
          timesteps.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="MaxStepDistance"
         command="SetMaxStepDistance"
         number_of_elements="3"
         animateable="1"
         default_values="1.0 1.0 1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If a particle disappears from one end of a simulation and
          reappears on the other side, the track left will be
          unrepresentative.  Set a MaxStepDistance{x,y,z} which acts as a
          threshold above which if a step occurs larger than the value (for
          the dimension), the track will be dropped and restarted after the
          step. (ie the part before the wrap around will be dropped and the
          newer part kept).
        </Documentation>
      </DoubleVectorProperty>

      <StringVectorProperty
          name="IdChannelArray"
          command="SetIdChannelArray"
          number_of_elements="1"
          default_values="Global or Local IDs"
          animateable="0">
          <ArrayListDomain
            name="array_list" attribute_type="Scalars"
            none_string="Global or Local IDs">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
        <Documentation>
          Specify the name of a scalar array which will be used to fetch
          the index of each point. This is necessary only if the particles
          change position (Id order) on each time step. The Id can be used
          to identify particles at each step and hence track them properly.
          If this array is set to "Global or Local IDs", the global point
          ids are used if they exist or the point index is otherwise.
        </Documentation>
      </StringVectorProperty>

   </SourceProxy>

   <!-- End TemporalPathLineFilter -->

   <!-- ==================================================================== -->
    <SourceProxy name="ParticleTracer" class="vtkTemporalStreamTracer">
    <Documentation
       long_help="Trace Particles through time in a vector field."
       short_help="Trace Particles through time in a vector field.">
The Particle Trace filter generates pathlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines. This filter is available on the Toolbar.
    </Documentation>

     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type" composite_data_supported="1">
         <DataType value="vtkDataObject"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" attribute_type="point"
                         number_of_components="3"/>
       <Documentation>
           Specify which is the Input of the StreamTracer filter.
       </Documentation>
     </InputProperty>

      <InputProperty
         name="Source"
         command="AddSourceConnection"
         clean_command="RemoveAllSources"
         multiple_input="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
            Specify the seed dataset. Typically fron where the vector field
            integration should begin. Usually a point/radius or a line with a
            given resolution.
        </Documentation>
      </InputProperty>

<!--
     <DoubleVectorProperty
        name="TimeStepResolution"
        command="SetTimeStepResolution"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
-->
     <IntVectorProperty
       name="TimeStep"
       command="SetTimeStep"
       number_of_elements="1"
       animateable="1"
       default_values="0"
       information_property="TimestepValues">

       <IntRangeDomain name="range">
         <RequiredProperties>
           <Property name="TimeStepRangeInfo" function="Range"/>
         </RequiredProperties>
       </IntRangeDomain>
       <Documentation>
         Set/Get the TimeStep. This is the primary means of advancing
         the particles. The TimeStep should be animated and this will drive
         the pipeline forcing timesteps to be fetched from upstream.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TimestepValues"
        information_only="1">
       <TimeStepsInformationHelper/>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="StaticSeeds"
        command="SetStaticSeeds"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Force the use of static seed optimizations
      </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="StaticMesh"
        command="SetStaticMesh"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Force the use of static mesh optimizations
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ForceReinjectionEveryNSteps"
        command="SetForceReinjectionEveryNSteps"
        number_of_elements="1"
        default_values="1" >
       <Documentation>
         When animating particles, it is nice to inject new ones every Nth step
         to produce a continuous flow. Setting ForceReinjectionEveryNSteps to a
         non zero value will cause the particle source to reinject particles
         every Nth step even if it is otherwise unchanged.
         Note that if the particle source is also animated, this flag will be
         redundant as the particles will be reinjected whenever the source changes
         anyway
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
        name="SelectInputVectors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
               Specify which vector array should be used for the integration
               through that filter.
           </Documentation>
     </StringVectorProperty>

      <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.25" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Specify the Initial step size used for line integration, expressed in:
          LENGTH_UNIT      = 1
          CELL_LENGTH_UNIT = 2
          (either the starting size for an adaptive integrator, e.g., RK45,
          or the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="ComputeVorticity"
         command="SetComputeVorticity"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Compute vorticity and angular rotation of particles as they progress
        </Documentation>
      </IntVectorProperty>

<!--
      <IntVectorProperty
        name="InitialIntegrationStepUnit"
        command="SetInitialIntegrationStepUnit"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <IntVectorProperty
        name="IntegratorType"
        command="SetIntegratorType"
        number_of_elements="1"
        default_values="0" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MinimumIntegrationStepUnit"
        command="SetMinimumIntegrationStepUnit"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumIntegrationStepUnit"
        command="SetMaximumIntegrationStepUnit"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
       </EnumerationDomain>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
-->

      <DoubleVectorProperty
         name="TerminationTime"
         command="SetTerminationTime"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          Setting TerminationTime to a positive value will cause particles
          to terminate when the time is reached. Use a vlue of zero to
          diable termination. The units of time should be consistent with the
          primary time variable.
        </Documentation>
      </DoubleVectorProperty>

     <IntVectorProperty
        name="TerminationTimeUnit"
        label="Termination Time Unit"
        command="SetTerminationTimeUnit"
        number_of_elements="1"
        default_values="1" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Simulation Time"/>
         <Entry value="1" text="TimeSteps"/>
       </EnumerationDomain>
       <Documentation>
         The termination time may be specified as TimeSteps or Simulation  time
       </Documentation>
     </IntVectorProperty>

      <DoubleVectorProperty
         name="TerminalSpeed"
         label="Term. Speed"
         command="SetTerminalSpeed"
         number_of_elements="1"
         default_values="0.000000000001" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          If at any point the speed is below the value of this property, the integration is terminated.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="IgnorePipelineTime"
         command="SetIgnorePipelineTime"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Ignore the TIME_ requests made by the pipeline and only use the TimeStep set manually
        </Documentation>
      </IntVectorProperty>

      <StringVectorProperty
         name="ParticleFileName"
         command="SetParticleFileName"
         number_of_elements="1"
         default_values="/project/csvis/biddisco/ptracer/run-1">
        <Documentation>
          Provide a name for the particle file generated if writing is enabled
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty
         name="EnableParticleWriting"
         command="SetEnableParticleWriting"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Turn On/Off particle writing
        </Documentation>
      </IntVectorProperty>

      <!-- End ParticleTracer -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="StructuredGridOutlineFilter"
                class="vtkStructuredGridOutlineFilter"
                label="Outline Curvilinear DataSet">
      <Documentation
         long_help="This filter generates an outline representation of the input."
         short_help="Generates an outline.">
The Outline filter generates an outline of the outside edges of the input dataset, rather than the dataset's bounding box. This filter operates on structured grid datasets and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkStructuredGrid"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the outline (curvilinear) filter.
           </Documentation>
      </InputProperty>
   <!-- End StructuredGridOutlineFilter -->
   </SourceProxy>

  <SourceProxy name="GenericClip" class="vtkGenericClip" label="Clip Generic Dataset">
    <Documentation
       long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
       short_help="Clip with an implicit plane, sphere or with scalars.">
The Generic Clip filter cuts away a portion of the input data set using a plane, a sphere, a box, or a scalar value. The menu in the Clip Function portion of the interface allows the user to select which implicit function to use or whether to clip using a scalar value. Making this selection loads the appropriate user interface. For the implicit functions, the appropriate 3D widget (plane, sphere, or box) is also displayed. The use of these 3D widgets, including their user interface components, is discussed in section 7.4.
If an implicit function is selected, the clip filter returns that portion of the input data set that lies inside the function. If Scalars is selected, then the user must specify a scalar array to clip according to. The clip filter will return the portions of the data set whose value in the selected Scalars array is larger than the Clip value. Regardless of the selection from the Clip Function menu, if the Inside Out option is checked, the opposite portions of the data set will be returned.
This filter operates on all types of data sets, and it returns unstructured grid data on output.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            optional="1"/>
          <Documentation>
            Set the input to the Generic Clip filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
               <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
              <Proxy group="implicit_functions" name="Scalar" />
           </ProxyListDomain>
           <Documentation>
             Set the parameters of the clip function.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Scalars">
           <ArrayListDomain name="array_list" attribute_type="Scalars">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
           <Documentation>
             If clipping with scalars, this property specifies the name of the scalar array on which to perform the clip operation.
           </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
        name="InsideOut"
        command="SetInsideOut"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Choose which portion of the dataset should be clipped away.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="Value"
        command="SetValue"
        number_of_elements="1"
        default_values="0.0" >
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <DoubleRangeDomain name="range"/>
          <Documentation>
            If clipping with a scalar array, choose the clipping value.
          </Documentation>
     </DoubleVectorProperty>

     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End GenericClip -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="GenericContour" class="vtkGenericContourFilter" label="Contour Generic Dataset">
    <Documentation
       long_help="Generate isolines or isosurfaces using point scalars."
       short_help="Generate isolines or isosurfaces.">
The Generic Contour filter computes isolines or isosurfaces using a selected point-centered scalar array. The available scalar arrays are listed in the Scalars menu. The scalar range of the selected array will be displayed.
The interface for adding contour values is very similar to the one for selecting cut offsets (in the Cut filter). To add a single contour value, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced contours, use the controls in the Generate range of values section. Select the number of contour values to generate using the Number of Values slider. The Range slider controls the interval in which to generate the contour values. Once the number of values and range have been selected, click the Generate button. The new values will be added to the Contour Values list. To delete a value from the Contour Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list. If no values are in the Contour Values list when Accept is pressed, the current value of the New Value slider will be used.
In addition to selecting contour values, you can also select additional computations to perform. If any of Compute Normals, Compute Gradients, or Compute Scalars is selected, the appropriate computation will be performed, and a corresponding point-centered array will be added to the output.
The Generic Contour filter operates on a generic data set, but the input is required to have at least one point-centered scalar (single-component) array. The output of this filter is polygonal.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="1" optional="1"/>
          <Documentation>
            Set the input to the Generic Contour filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Contour By">
          <ArrayListDomain name="array_list" attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
           <FieldDataDomain name="field_list">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </FieldDataDomain>
          <Documentation>
            This property specifies the name of the scalar array from which the contour filter will compute isolines and/or isosurfaces.
          </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        label="Isosurfaces"
        set_number_command="SetNumberOfContours"
        number_of_elements="0"
        repeat_command="1"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1">
          <ArrayRangeDomain name="scalar_range">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
               <Property name="SelectInputScalars" function="ArraySelection"/>
            </RequiredProperties>
          </ArrayRangeDomain>
          <Documentation>
            This property specifies the values at which to compute isosurfaces/isolines and also the number of such values.
          </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="ComputeNormals"
        command="SetComputeNormals"
        number_of_elements="1"
        default_values="1"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute normals.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeGradients"
        command="SetComputeGradients"
        number_of_elements="1"
        default_values="0"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute gradients.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeScalars"
        command="SetComputeScalars"
        number_of_elements="1"
        default_values="0"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to compute scalars.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>

     <!-- incremental point locator begin -->
     <ProxyProperty name="Locator" command="SetLocator"
       label="Point Merge Method">
       <ProxyGroupDomain name="groups">
         <Group name="incremental_point_locators" />
       </ProxyGroupDomain>
       <ProxyListDomain name="proxy_list">
         <Proxy group="incremental_point_locators" name="MergePoints" />
         <Proxy group="incremental_point_locators" name="IncrementalOctreeMergePoints" />
         <Proxy group="incremental_point_locators" name="NonMergingPointLocator" />
       </ProxyListDomain>
       <Documentation>
         This property specifies an incremental point locator for merging duplicate / coincident points.
       </Documentation>
     </ProxyProperty>
     <!-- incremental point locator end -->

   <!-- End GenericContour -->
   </SourceProxy>

   <!-- ==================================================================== -->
 <SourceProxy name="GenericCut" class="vtkGenericCutter" label="Slice Generic Dataset">
    <Documentation
       long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
       short_help="Cut datasets with planes or spheres.">
The Generic Cut filter extracts the portion of the input data set that lies along the specified plane or sphere. From the Cut Function menu, you can select whether cutting will be performed with a plane or a sphere. The appropriate 3D widget (plane widget or sphere widget) will be displayed. The parameters of the cut function can be specified interactively using the 3D widget or manually using the traditional user interface controls. Instructions for using these 3D widgets and their corresponding user interfaces are found in section 7.4.
By default, the cut lies on the specified plane or sphere. Using the Cut Offset Values portion of the interface, it is also possible to cut the data set at some offset from the original cut function. The Cut Offset Values are in the spatial units of the data set. To add a single offset, select the value from the New Value slider in the Add value portion of the interface and click the Add button, or press Enter. To instead add several evenly spaced offsets, use the controls in the Generate range of values section. Select the number of offsets to generate using the Number of Values slider. The Range slider controls the interval in which to generate the offsets. Once the number of values and range have been selected, click the Generate button. The new offsets will be added to the Offset Values list. To delete a value from the Cut Offset Values list, select the value and click the Delete button. (If no value is selected, the last value in the list will be removed.) Clicking the Delete All button removes all the values in the list.
The Generic Cut filter takes a generic dataset as input. Use the Input menu to choose a data set to cut. The output of this filter is polygonal data.
    </Documentation>
    <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Generic Cut filter.
          </Documentation>
     </InputProperty>

     <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Cut Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             Set the parameters to the implicit function used for cutting.
           </Documentation>
     </ProxyProperty>

     <DoubleVectorProperty
        name="InputBounds"  information_only="1">
       <BoundsDomain name="bounds">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="ContourValues"
        command="SetValue"
        repeat_command="1"
        set_number_command="SetNumberOfContours"
        number_of_elements_per_command="1"
        use_index="1"
        animateable="1"
        label="Slice Offset Values">
          <BoundsDomain name="bounds" mode="magnitude">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </BoundsDomain>
          <Documentation>
            The values in this property specify a list of current offset values. This can be used to create multiple slices with different centers. Each entry represents a new slice with its center shifted by the offset value.
          </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End GenericCut -->
   </SourceProxy>

   <!-- ==================================================================== -->
  <SourceProxy name="GenericGeometryFilter" class="vtkGenericGeometryFilter"
               label="Extract Generic Dataset Surface">
     <Documentation
         long_help="Extract geometry from a higher-order dataset"
         short_help="Extract geometry from a higher-order dataset">
Extract geometry from a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Geometry Filter.
           </Documentation>
      </InputProperty>

     <IntVectorProperty
        name="PassThroughCellIds"
        command="SetPassThroughCellIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         Select whether to forward original ids.
       </Documentation>
     </IntVectorProperty>


   <!-- End GenericGeometryFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
 <SourceProxy name="GenericOutlineFilter" class="vtkGenericOutlineFilter"
     label="Outline Generic DataSet">
     <Documentation
       long_help="This filter generates a bounding box representation of the input."
       short_help="Generates a bounding box.">
The Generic Outline filter generates an axis-aligned bounding box for the input data set. The Input menu specifies the data set for which to create a bounding box. This filter operates on generic data sets and produces polygonal output.
     </Documentation>

     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Outline filter.
           </Documentation>
      </InputProperty>
     <Hints>
       <Visibility replace_input="0" />
     </Hints>
   <!-- End  GenericOutlineFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
 <SourceProxy name="GenericStreamTracer" class="vtkGenericStreamTracer"
              label="Stream Tracer For Generic Datasets">
    <Documentation
       long_help="Integrate streamlines in a vector field."
       short_help="Integrate streamlines in a vector field.">
The Generic Stream Tracer filter generates streamlines in a vector field from a collection of seed points. The vector field used is selected from the Vectors menu, so the input data set is required to have point-centered vectors. The Seed portion of the interface allows you to select whether the seed points for this integration lie in a point cloud or along a line. Depending on which is selected, the appropriate 3D widget (point or line widget) is displayed along with traditional user interface controls for positioning the point cloud or line within the data set. Instructions for using the 3D widgets and the corresponding manual controls can be found in section 7.4.
The Max. Propagation entry box allows you to specify the maximum length of the streamlines. From the Max. Propagation menu, you can select the units to be either Time (the time a particle would travel with steady flow) or Length (in the data set's spatial coordinates).
The Init. Step Len. menu and entry specify the initial step size for integration. (For non-adaptive integrators, Runge-Kutta 2 and 4, the initial step size is used throughout the integration.) The menu allows you to specify the units. Time and Length have the same meaning as for Max. Propagation. Cell Length specifies the step length as a number of cells.
The Integration Direction menu determines in which direction(s) the stream trace will be generated: FORWARD, BACKWARD, or BOTH.
The Integrator Type section of the interface determines which calculation to use for integration: Runge-Kutta 2, Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is selected, controls are displayed for specifying the minimum and maximum step length and the maximum error. The controls for specifying Min. Step Len. and Max. Step Len. are the same as those for Init. Step Len. The Runge-Kutta 4-5 integrator tries to choose the step size so that the estimated error is less than the value of the Maximum Error entry.
If the integration takes more than Max. Steps to complete, if the speed goes below Term. Speed, if Max. Propagation is reached, or if a boundary of the input data set is crossed, integration terminates.
This filter operates on any type of data set, provided it has point-centered vectors. The output is polygonal data containing polylines.
    </Documentation>

    <InputProperty
       name="Input"
       command="AddInputConnection"
       clean_command="RemoveAllInputs"
       multiple_input="1">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkGenericDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array" attribute_type="point"
                            number_of_components="3"/>
          <Documentation>
            Set the input to the Generic Stream Tracer filter.
          </Documentation>
     </InputProperty>

     <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Seed Type">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="extended_sources" name="PointSource" />
              <Proxy group="extended_sources" name="HighResLineSource" />
           </ProxyListDomain>
           <Documentation>
             The value of this property determines how the seeds for the streamlines will be generated.
           </Documentation>
      </InputProperty>

     <StringVectorProperty
       name="SelectInputVectors"
       command="SetInputArrayToProcess"
       number_of_elements="5"
       element_types="0 0 0 0 2"
       animateable="0"
       label="Vectors">
           <ArrayListDomain name="array_list" attribute_type="Vectors">
             <RequiredProperties>
                <Property name="Input" function="Input"/>
             </RequiredProperties>
           </ArrayListDomain>
           <Documentation>
             This property contains the name of the vector array from which to generate streamlines.
           </Documentation>
     </StringVectorProperty>

     <DoubleVectorProperty
        name="MaximumPropagation"
        command="SetMaximumPropagation"
        number_of_elements="1"
        default_values="1.0" >
       <BoundsDomain name="bounds" mode="scaled_extent" scale_factor="1.0">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
         </RequiredProperties>
       </BoundsDomain>
       <Documentation>
         Specify the maximum streamline length.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="InitialIntegrationStep"
        command="SetInitialIntegrationStep"
        number_of_elements="1"
        default_values="0.5" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the initial integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="IntegrationDirection"
        command="SetIntegrationDirection"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="FORWARD"/>
         <Entry value="1" text="BACKWARD"/>
         <Entry value="2" text="BOTH"/>
       </EnumerationDomain>
       <Documentation>
         This property determines in which direction(s) a streamline is generated.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="IntegratorType"
        command="SetIntegratorType"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Runge-Kutta 2"/>
         <Entry value="1" text="Runge-Kutta 4"/>
         <Entry value="2" text="Runge-Kutta 4-5"/>
       </EnumerationDomain>
       <Documentation>
         This property determines which integrator (with increasing accuracy) to use for creating streamlines.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumError"
        command="SetMaximumError"
        number_of_elements="1"
        default_values="0.000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Set the maximum error allowed in the integration. The meaning of
         this value depends on the integrator chosen.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="MinimumIntegrationStep"
        command="SetMinimumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the minimum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="IntegrationStepUnit"
        command="SetIntegrationStepUnit"
        number_of_elements="1"
        default_values="2" >
       <EnumerationDomain name="enum">
         <Entry value="0" text="Time"/>
         <Entry value="1" text="Length"/>
         <Entry value="2" text="Cell Length"/>
       </EnumerationDomain>
       <Documentation>
         Choose the unit to use for the integration step.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MaximumIntegrationStep"
        command="SetMaximumIntegrationStep"
        number_of_elements="1"
        default_values="0.01" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         Specify the maximum integration step.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="MaximumNumberOfSteps"
        command="SetMaximumNumberOfSteps"
        number_of_elements="1"
        default_values="2000" >
       <IntRangeDomain name="range"/>
       <Documentation>
         Specify the maximum number of steps used in the integration.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="TerminalSpeed"
        command="SetTerminalSpeed"
        number_of_elements="1"
        default_values="0.000000000001" >
       <DoubleRangeDomain name="range"/>
       <Documentation>
         If at any point the speed is below this value, the integration is terminated.
       </Documentation>
     </DoubleVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   <!-- End GenericStreamTracer -->
   </SourceProxy>

   <!-- ==================================================================== -->
  <SourceProxy name="GenericTessellator" class="vtkGenericDataSetTessellator"
               label="Tessellate Generic Dataset">
     <Documentation
         long_help="Tessellate a higher-order dataset"
         short_help="Tessellate a higher-order dataset">
Tessellate a higher-order dataset.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkGenericDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Generic Tessellator filter.
           </Documentation>
      </InputProperty>

   <!-- End GenericTessellator -->
   </SourceProxy>

   <SourceProxy name="GroupDataSets" class="vtkMultiBlockDataGroupFilter"
    label="Group Datasets">
    <Documentation
        long_help="Group data sets."
        short_help="Group multiple inputs into one collection.">
        Groups multiple datasets to create a multiblock dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="AddInputConnection"
        clean_command="RemoveAllInputs"
        multiple_input="1">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type" composite_data_supported="1">
             <DataType value="vtkDataObject"/>
           </DataTypeDomain>
           <Documentation>
             This property indicates the the inputs to the Group Datasets filter.
           </Documentation>
     </InputProperty>
     <Hints>
       <Visibility replace_input="1" />
     </Hints>
   <!-- End GroupDataSets -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="BlockIdScalars" class="vtkBlockIdScalars"
      label="Block Scalars">
     <Documentation
        long_help="The Level Scalars filter uses colors to show levels of a multiblock dataset."
        short_help="Generate point scalars from level.">
        The Level Scalars filter uses colors to show levels of a multiblock dataset.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiBlockDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Level Scalars filter.
           </Documentation>
     </InputProperty>
   <!-- End GroupIdScalars -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="LevelIdScalars" class="vtkLevelIdScalars"
      label="Level Scalars">
     <Documentation
        long_help="The Level Scalars filter uses colors to show levels of a hierarchical dataset."
        short_help="Generate point scalars from level.">
        The Level Scalars filter uses colors to show levels of a hierarchical dataset.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHierarchicalBoxDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Level Scalars filter.
           </Documentation>
     </InputProperty>
   <!-- End GroupIdScalars -->
   </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="GeometryFilter" class="vtkPVGeometryFilter">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the Geoemtry Filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="UseStrips"
        command="SetUseStrips"
        number_of_elements="1"
        is_internal="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to generate faces containing triangle strips.
          This should render faster and use less memory, but no cell data is copied.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="ForceStrips"
        command="SetForceUseStrips"
        number_of_elements="1"
        is_internal="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          This makes UseStrips call Modified() after changing its setting to ensure that the filter's output is immediatley changed.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="UseOutline"
        command="SetUseOutline"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to generate an outline or a surface.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty name="NonlinearSubdivisionLevel"
                         command="SetNonlinearSubdivisionLevel"
                         number_of_elements="1"
                         default_values="1">
        <IntRangeDomain name="range" min="0" max="4" />
        <Documentation>
          Nonlinear faces are approximated with flat polygons.  This
          parameter controls how many times to subdivide nonlinear surface
          cells.  Higher subdivisions generate closer approximations but
          take more memory and rendering time.  Subdivision is recursive,
          so the number of output polygons can grow exponentially with this
          parameter.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughIds"
        command="SetPassThroughCellIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          If on, the output polygonal dataset will have a celldata array that holds the cell index of the original 3D cell that produced each output cell. This is useful for cell picking.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="PassThroughPointIds"
        command="SetPassThroughPointIds"
        number_of_elements="1"
        default_values="1"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          If on, the output polygonal dataset will have a pointdata array that holds the point index of the original 3D vertex that produced each output vertex. This is useful for picking.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="MakeOutlineOfInput"
        command="SetMakeOutlineOfInput"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Causes filter to try to make geometry of input to the algorithm on its input.
        </Documentation>
      </IntVectorProperty>

    <!-- End GeometryFilter -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="FlattenFilter" class="vtkMergeCompositeDataSet">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPointSet"/>
            <DataType value="vtkGraph"/>
            <DataType value="vtkCompositeDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Flatten Filter.
          </Documentation>
      </InputProperty>
    </SourceProxy>
   <!-- ==================================================================== -->
    <SourceProxy name="OrderedCompositeDistributor"
                 class="vtkOrderedCompositeDistributor">
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the input to the Ordered Composite Distributor filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty name="PassThrough"
                         command="SetPassThrough"
                         number_of_elements="1"
                         default_values="0"
                         animateable="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          Toggle whether to pass the data through without compositing.
        </Documentation>
      </IntVectorProperty>
      <ProxyProperty name="PKdTree" command="SetPKdTree">
        <ProxyGroupDomain name="groups">
          <Group name="locators"/>
        </ProxyGroupDomain>
        <Documentation>
          Set the vtkPKdTree to distribute with.
        </Documentation>
      </ProxyProperty>
      <StringVectorProperty name="OutputType"
                            command="SetOutputType"
                            number_of_elements="1">
        <Documentation>
          When not empty, the output will be converted to the given type.
        </Documentation>
      </StringVectorProperty>
    <!-- End OrderedCompositeDistributor -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="UpdateSuppressor2" class="vtkPVUpdateSuppressor"
      executive="vtkUpdateSuppressorPipeline">

      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Update Suppressor filter.
          </Documentation>
      </InputProperty>

      <Property name="ForceUpdate" command="ForceUpdate" />

      <IntVectorProperty
        name="Enabled"
        command="SetEnabled"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether the update suppressor is enabled.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
        name="UpdateTime"
        command="SetUpdateTime"
        number_of_elements="1"
        default_values="none"
        immediate_update="1"
        is_internal="1">
        <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>

      <!-- End UpdateSuppressor2 -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="CacheKeeper" class="vtkPVCacheKeeper"
      executive="vtkPVCacheKeeperPipeline">
      <Documentation>
        vtkPVCacheKeeper manages data cache for flip book animations.  When
        caching is disabled, this simply acts as a pass through filter.  When
        caching is enabled, is the current time step has been previously cached
        then this filter shuts the update request, otherwise propagates the
        update and then cache the result for later use.  The current time step
        is set using SetCacheTime().
      </Documentation>

      <InputProperty name="Input"
        command="SetInputConnection">
          <Documentation>
            Set the input to the Update Suppressor filter.
          </Documentation>
      </InputProperty>

      <Property name="RemoveAllCaches" command="RemoveAllCaches" />

      <DoubleVectorProperty name="CacheTime"
        command="SetCacheTime"
        number_of_elements="1"
        default_values="0.0" >
        <DoubleRangeDomain name="range" />
      </DoubleVectorProperty>

      <IntVectorProperty name="CachingEnabled"
        command="SetCachingEnabled"
        number_of_elements="1"
        is_internal="1"
        default_values="1" >
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle whether the caching is enabled.
        </Documentation>
      </IntVectorProperty>
      <!-- End of CacheKeeper -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="MPIMoveData" class="vtkMPIMoveData">
      <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <!-- Does this have any data type domain? -->
          <Documentation>
            Set the input to the MPI Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="MoveMode"
        command="SetMoveMode"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PassThrough" />
          <Entry value="1" text="Collect" />
          <Entry value="2" text="Clone" />
        </EnumerationDomain>
        <Documentation>
          Specify how the data is to be redistributed.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="none"
        animateable="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="PolyData" />
          <Entry value="4" text="Unstructured Grid" />
          <Entry value="6" text="ImageData" />
        </EnumerationDomain>
        <Documentation>
          Specify the type of the dataset.
        </Documentation>
      </IntVectorProperty>
    <!-- End MPIMoveData -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="ClientServerMoveData" class="vtkClientServerMoveData"
      processes="client|dataserver">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Client Server Move Data filter.
          </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="OutputDataType"
        command="SetOutputDataType"
        number_of_elements="1"
        default_values="0"
        animateable="0">
      </IntVectorProperty>
      <IntVectorProperty name="WholeExtent"
        command="SetWholeExtent"
        number_of_elements="6"
        default_values="0 -1 0 -1 0 -1">
      </IntVectorProperty>
    <!-- End ClientServerMoveData -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <SourceProxy name="ReductionFilter" class="vtkReductionFilter">
      <InputProperty name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <Documentation>
            Set the input to the Reduction filter.
          </Documentation>
      </InputProperty>
      <StringVectorProperty name="PreGatherHelperName"
         command="SetPreGatherHelperName"
         number_of_elements="1">
         <Documentation>
           Set the algorithm that runs on each node in parallel.
         </Documentation>
      </StringVectorProperty>
      <StringVectorProperty name="PostGatherHelperName"
         command="SetPostGatherHelperName"
         number_of_elements="1">
         <Documentation>
           Set the algorithm that takes multiple inputs and produces a single reduced output.
         </Documentation>
      </StringVectorProperty>

      <ProxyProperty name="PostGatherHelper"
        command="SetPostGatherHelper"/>

      <ProxyProperty name="PreGatherHelper"
        command="SetPreGatherHelper"/>

      <IntVectorProperty
         name="PassThrough"
         command="SetPassThrough"
         number_of_elements="1"
         default_values="-1">
        <IntRangeDomain name="range" min="-1"/>
        <Documentation>
          If set to a non-negative value, then produce results using only the node Id specified.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty
         name="GenerateProcessIds"
         command="SetGenerateProcessIds"
         number_of_elements="1"
         default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          If true, the filter will generate vtkOriginalProcessIds arrays
          indicating the process id on which the cell/point was generated.
        </Documentation>
      </IntVectorProperty>

    <!-- End ReductionFilter -->
    </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractHierarchicalLevel" class="vtkExtractLevel"
     label="Extract Level">
     <Documentation
        long_help="This filter extracts a range of groups from a hierarchical dataset."
        short_help="Extract level.">
      This filter extracts a range of levels from a hierarchical dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHierarchicalBoxDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Group filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="Levels"
        command="AddLevel"
        clean_command="RemoveAllLevels"
        repeat_command="1"
        number_of_elements_per_command="1">
        <Hints>
          <!-- Tells the widget not to use flat-indicies for this property.
                Only needed when number_of_elements_per_command==1
          -->
          <UseFlatIndex value="0" />
        </Hints>
       <CompositeTreeDomain name="tree" mode="leaves">
          <!-- mode="leaves" since multi-pieces are treated as a single leaf
               node wth the exception of vtkExtractDataSets -->
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </CompositeTreeDomain>
       <Documentation>
         This property lists the levels to extract
         from the input hierarchical dataset.
       </Documentation>
     </IntVectorProperty>

    <!-- End ExtractHierarchicalLevel -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractBlock" class="vtkExtractBlock"
     label="Extract Block">
     <Documentation
        long_help="This filter extracts a range of blocks from a multiblock dataset."
        short_help="Extract block.">
This filter extracts a range of groups from a multiblock dataset
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkMultiBlockDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Group filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="BlockIndices"
        command="AddIndex"
        clean_command="RemoveAllIndices"
        repeat_command="1"
        number_of_elements_per_command="1">
       <CompositeTreeDomain name="tree" mode="all">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </CompositeTreeDomain>
       <Documentation>
         This property lists the ids of the blocks to extract
         from the input multiblock dataset.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="PruneOutput"
        command="SetPruneOutput"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          When set, the output mutliblock dataset will be pruned to remove empty
          nodes. On by default.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="MaintainStructure"
        command="SetMaintainStructure"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          This is used only when PruneOutput is ON. By default, when pruning the
          output i.e. remove empty blocks, if node has only 1 non-null child
          block, then that node is removed. To preserve these parent nodes, set
          this flag to true.
        </Documentation>
     </IntVectorProperty>

    <!-- End ExtractBlock -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractHierarchicalDataSets"
                class="vtkExtractDataSets"
                label="Extract AMR Blocks">
     <Documentation
        long_help="This filter extracts a list of datasets from hierarchical datasets."
        short_help="Extract datasets.">
This filter extracts a list of datasets from hierarchical datasets.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkHierarchicalBoxDataSet"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input to the Extract Datasets filter.
           </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="SelectedDataSets"
        command="AddDataSet"
        clean_command="ClearDataSetList"
        repeat_command="1"
        number_of_elements_per_command="2">
       <CompositeTreeDomain name="tree" mode="leaves">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
       </CompositeTreeDomain>
        <Documentation>
          This property provides a list of datasets to extract.
        </Documentation>
     </IntVectorProperty>
   <!-- End ExtractDataSets -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractHistogram" class="vtkPExtractHistogram"
                label="Histogram">
     <Documentation
        long_help="Extract a histogram from field data."
        short_help="Extract a histogram from field data.">
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <InputArrayDomain name="input_array">
             <RequiredProperties>
                <Property name="SelectInputArray"
                          function="FieldDataSelection"/>
             </RequiredProperties>
          </InputArrayDomain>
          <Documentation>
            This property specifies the input to the Histogram filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputArray"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0">
          <ArrayListDomain name="array_list"
                           attribute_type="Scalars">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <FieldDataDomain name="field_list">
            <RequiredProperties>
               <Property name="Input" function="Input"/>
            </RequiredProperties>
          </FieldDataDomain>
          <Documentation>
            This property indicates the name of the array from which to compute the histogram.
          </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="BinCount"
        command="SetBinCount"
        number_of_elements="1"
        default_values="10">
        <IntRangeDomain name="range" min="1" max="256"/>
        <Documentation>
          The value of this property specifies the number of bins for the histogram.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="Component"
        command="SetComponent"
        number_of_elements="1"
        default_values="0"
        animateable="0">
        <NumberOfComponentsDomain name="comps">
          <RequiredProperties>
            <Property name="Input" function="Input" />
               <Property name="SelectInputArray" function="ArraySelection"/>
          </RequiredProperties>
        </NumberOfComponentsDomain>
        <Documentation>
          The value of this property specifies the array component from which the histogram should be computed.
        </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="CalculateAverages"
        command="SetCalculateAverages"
        number_of_elements="1"
        default_values="1" >
       <BooleanDomain name="bool"/>
       <Documentation>
         This option controls whether the algorithm calculates averages
         of variables other than the primary variable that fall into each
         bin.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="UseCustomBinRanges"
       command="SetUseCustomBinRanges"
       number_of_elements="1"
       default_values="0">
       <BooleanDomain name="bool" />
       <Documentation>
         When set to true, CustomBinRanges will  be used instead of using the
         full range for the selected array. By default, set to false.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="CustomBinRanges"
       command="SetCustomBinRanges"
       number_of_elements="2"
       default_values="0.0 100.0">
       <Documentation>
         Set custom bin ranges to use. These are used only when
         UseCustomBinRanges is set to true.
       </Documentation>
       <ArrayRangeDomain name="scalar_range">
         <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputArray" function="ArraySelection"/>
         </RequiredProperties>
       </ArrayRangeDomain>
     </DoubleVectorProperty>

     <Hints>
       <!-- View can be used to specify the preferred view for the proxy -->
       <View type="XYBarChartView" />
       <Plotable />
     </Hints>

   <!-- End ExtractHistogram -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ScatterPlot" class="vtkPassThrough"
                label="Scatter Plot">
     <Documentation
        long_help="Creates a scatter plot from a dataset."
        short_help="Creates a scatter plot from a dataset.">
        This filter creates a scatter plot from a dataset.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            This property specifies the input to the filter.
          </Documentation>
     </InputProperty>

     <Hints>
        <Visibility replace_input="0" />
       <!-- View can be used to specify the preferred view for the proxy -->
       <View type="XYChartView" />
       <Plotable />
     </Hints>
   <!-- End ScatterPlot -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="RectilinearGridGeometryFilter" class="vtkRectilinearGridGeometryFilter">
      <Documentation
         long_help="Extracts geometry for a rectilinear grid.  Output is a polydata dataset."
         short_help="Extracts geometry for a rectilinear grid.">
         RectilinearGridGeometryFilter is a filter that extracts geometry from a rectilinear grid. By specifying appropriate i-j-k indices, it is possible to extract a point, a curve, a surface, or a "volume".  The volume is actually a (n x m x o) region of points.  The extent specification is zero-offset.  That is, the first k-plane in a 50x50x50 rectilinear grid is given by (0,49, 0,49, 0,0).
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <Documentation>
             Set the input to the Rectilinear Grid Geometry filter.
           </Documentation>
      </InputProperty>

   <!-- End RectilinearGridGeometryFilter -->
   </SourceProxy>

   <SourceProxy name="TextureMapToPlane" class="vtkTextureMapToPlane"
     label="Texture Map to Plane">
     <Documentation
      short_help="Generate texture coordinates by mapping points to plane."
      long_help="Generate texture coordinates by mapping points to plane." >
      TextureMapToPlane is a filter that generates 2D texture coordinates by
      mapping input dataset points onto a plane. The plane is generated
      automatically. A least squares method is used to generate the plane
      automatically.
     </Documentation>
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Plane filter.
          </Documentation>
     </InputProperty>
   <!-- End TextureMapToPlane -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TextureMapToSphere" class="vtkTextureMapToSphere"
     label="Texture Map to Sphere">
     <Documentation
      short_help= "Generate texture coordinates by mapping points to sphere."
      long_help= "Generate texture coordinates by mapping points to sphere." >
      This is a filter that generates 2D texture coordinates by mapping input
      dataset points onto a sphere. The sphere is generated automatically. The
      sphere is generated automatically by computing the center i.e. averaged
      coordinates, of the sphere. Note that the generated texture coordinates
      range between (0,1). The s-coordinate lies in the angular direction around
      the z-axis, measured counter-clockwise from the x-axis. The t-coordinate
      lies in the angular direction measured down from the north pole towards
      the south pole.
     </Documentation>
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Sphere filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty name="PreventSeam"
                        command="SetPreventSeam"
                        number_of_elements="1"
                        default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Control how the texture coordinates are generated. If Prevent Seam
         is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding
         to the theta angle variation between 0-&gt;180 and 180-&gt;0
         degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between
         0-&gt;360 degrees.
       </Documentation>
     </IntVectorProperty>
   <!-- End TextureMapToSphere -->
   </SourceProxy>

   <SourceProxy name="TextureMapToCylinder" class="vtkTextureMapToCylinder"
     label="Texture Map to Cylinder">
     <Documentation
      short_help="Generate texture coordinates by mapping points to cylinder."
      long_help="Generate texture coordinates by mapping points to cylinder." >
     This is a filter that generates 2D texture coordinates by mapping input
     dataset points onto a cylinder. The cylinder is generated automatically.
     The cylinder is generated automatically by computing the axis of the
     cylinder. Note that the generated texture coordinates for the s-coordinate
     ranges from (0-1) (corresponding to angle of 0->360 around axis), while the
     mapping of the t-coordinate is controlled by the projection of points along
     the axis.
     </Documentation>
     <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Texture Map to Cylinder filter.
          </Documentation>
     </InputProperty>

     <IntVectorProperty name="PreventSeam"
                        command="SetPreventSeam"
                        number_of_elements="1"
                        default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Control how the texture coordinates are generated. If Prevent Seam
         is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0 corresponding
         to the theta angle variation between 0-&gt;180 and 180-&gt;0
         degrees. Otherwise, the s-coordinate ranges from 0-&gt;1 between
         0-&gt;360 degrees.
       </Documentation>
     </IntVectorProperty>
   <!-- End TextureMapToCylinder -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PolyLineToRectilinearGrid"
                class="vtkPolyLineToRectilinearGridFilter"
                label="PolyLine To Rectilinear Grid">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkPolyData"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Polyline to Rectilinear Grid filter.
          </Documentation>
     </InputProperty>
     <!-- End PolyLineToRectilinearGrid -->
   </SourceProxy>

   <SourceProxy name="MinMax" class="vtkMinMax">
      <InputProperty
       name="Input"
       command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkDataSet"/>
          </DataTypeDomain>
          <Documentation>
            Set the input to the Min Max filter.
          </Documentation>
     </InputProperty>

     <StringVectorProperty
        name="Operation"
        command="SetOperation"
        number_of_elements="1"
        default_values="MIN">
        <StringListDomain name="operation">
          <String value="MIN"/>
          <String value="MAX"/>
          <String value="SUM"/>
        </StringListDomain>
        <Documentation>
          Select whether to perform a min, max, or sum operation on the data.
        </Documentation>
     </StringVectorProperty>
     <!-- End MinMax -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="PVExtractSelection" label="Extract Selection (internal)"
                class="vtkPVExtractSelection">
     <Documentation>
       This filter extracts a given set of cells or points given a selection.
       The selection can be obtained from a rubber-band selection
       (either point, cell, visible or in a frustum) and passed to the filter
       or specified by providing an ID list.
       This is an internal filter, use "ExtractSelection" instead.
     </Documentation>

     <InputProperty
         name="Input"
         command="SetInputConnection"
         clean_command="RemoveAllInputs">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <Documentation>
         The input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="Selection"
         command="SetSelectionConnection"
         clean_command="RemoveAllSelectionsInputs">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkSelection"/>
       </DataTypeDomain>
       <Documentation>
         The input that provides the selection object.
       </Documentation>
     </InputProperty>

     <IntVectorProperty
        name="PreserveTopology"
        command="SetPreserveTopology"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1 the output preserves the topology of its
         input and adds an insidedness array to mark which cells are inside or
         out. If 0 then the output is an unstructured grid which contains only
         the subset of cells that are inside.
       </Documentation>
     </IntVectorProperty>

     <!-- End ExtractSelection -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="TimeToTextConvertor" class="vtkTimeToTextConvertor"
     label="Annotate Time Filter" >
     <Documentation
        short_help="Show data time as text."
        long_help="Shows input data time as text annnotation in the view." >
        The Annotate Time filter can be used to show the data time in a text annotation.
     </Documentation>
     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <Documentation>
         This property specifies the input dataset for which to display the time.
       </Documentation>
     </InputProperty>
     <StringVectorProperty
       name="Format"
       command="SetFormat"
       number_of_elements="1"
       default_values="Time: %f">
       <Documentation>
         The value of this property is a format string used to display the input time. The format string is specified using printf style.
       </Documentation>
     </StringVectorProperty>

      <DoubleVectorProperty
         name="Shift"
         command="SetShift"
         number_of_elements="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The amount of time the input is shifted (after scaling).
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Scale"
         command="SetScale"
         number_of_elements="1"
         default_values="1.0" >
        <DoubleRangeDomain name="range"/>
        <Documentation>
          The factor by which the input time is scaled.
        </Documentation>
      </DoubleVectorProperty>

     <Hints>
       <Visibility replace_input="0" />
       <OutputPort name="Output-0" index="0" type="text" />
     </Hints>

   <!-- End of TimeToTextConvertor -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="CellDerivatives" class="vtkCellDerivatives"
     label="Compute Derivatives">
     <Documentation
        long_help="This filter computes derivatives of scalars and vectors."
        short_help="Computes derivatives of scalars/vectors.">
CellDerivatives is a filter that computes derivatives of scalars and vectors at the center of cells. You can choose to generate different output including the scalar gradient (a vector), computed tensor vorticity (a vector), gradient of input vectors (a tensor), and strain matrix of the input vectors (a tensor); or you may choose to pass data through to the output.
     </Documentation>
     <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>
           <InputArrayDomain name="input_array1" attribute_type="point"
                             number_of_components="1" optional="1"/>
           <InputArrayDomain name="input_array2" attribute_type="point"
                             number_of_components="3" optional="1"/>
           <Documentation>
             This property specifies the input to the filter.
           </Documentation>
      </InputProperty>

      <StringVectorProperty
          name="SelectInputScalars"
          command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2"
          label="Scalars">
        <ArrayListDomain name="array_list" attribute_type="Scalars"
                         input_domain_name="input_array1">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property indicates the name of the scalar array to differentiate.
        </Documentation>
      </StringVectorProperty>

      <StringVectorProperty
          name="SelectInputVectors"
          command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2"
          default_values="1"
          label="Vectors">
        <ArrayListDomain name="array_list" attribute_type="Vectors"
                         input_domain_name="input_array2">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property indicates the name of the vector array to differentiate.
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty
        name="OutputVectorType"
        command="SetVectorMode"
        number_of_elements="1"
        default_values="1">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Nothing"/>
         <Entry value="1" text="Scalar Gradient"/>
         <Entry value="2" text="Vorticity"/>
       </EnumerationDomain>
       <Documentation>
This property Controls how the filter works to generate vector cell data. You can choose to compute the gradient of the input scalars, or extract the vorticity of the computed vector gradient tensor. By default, the filter will take the gradient of the input scalar data.
       </Documentation>
     </IntVectorProperty>

      <IntVectorProperty
        name="OutputTensorType"
        command="SetTensorMode"
        number_of_elements="1"
        default_values="1">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Nothing"/>
         <Entry value="1" text="Vector Gradient"/>
         <Entry value="2" text="Strain"/>
       </EnumerationDomain>
       <Documentation>
This property controls how the filter works to generate tensor cell data. You can choose to compute the gradient of the input vectors, or compute the strain tensor of the vector gradient tensor. By default, the filter will take the gradient of the vector data to construct a tensor.
       </Documentation>
     </IntVectorProperty>
   <!-- End CellDerivatives -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ExtractSelection" class="vtkExtractSelection"
      label="Extract Selection">
     <Documentation
        short_help="Extract different type of selections."
        long_help="Extract different type of selections." >
       This filter extracts a set of cells/points given a selection.
       The selection can be obtained from a rubber-band selection
       (either cell, visible or in a frustum) or threshold selection
       and passed to the filter or specified by providing an ID list.
     </Documentation>

     <InputProperty name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
         <DataType value="vtkTable"/>
       </DataTypeDomain>
       <Documentation>
         This property specifies the input from which the selection is extracted.
       </Documentation>
     </InputProperty>

     <InputProperty name="Selection"
         command="SetSelectionConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkSelection"/>
       </DataTypeDomain>
       <Documentation>
         The input that provides the selection object.
       </Documentation>
       <Hints>
         <!-- This tag alerts the auto-generated panels and input selection
              that this input is a selection.  It should use the special
              selection GUI. -->
         <SelectionInput />
       </Hints>
     </InputProperty>

     <IntVectorProperty
        name="PreserveTopology"
        command="SetPreserveTopology"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set to 1 the output preserves the topology of its
         input and adds an insidedness array to mark which cells are inside or
         out. If 0 then the output is an unstructured grid which contains only
         the subset of cells that are inside.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ShowBounds"
        command="SetShowBounds"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
       <Documentation>
         For frustum selection, if this property is set to 1 the output is the
         outline of the frustum instead of the contents of the input that lie
         within the frustum.
       </Documentation>
     </IntVectorProperty>

     <!-- End of ExtractSelection -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="ConvertSelection" class="vtkPConvertSelection">
      <Documentation>
        Converts a selection from one type to another.
      </Documentation>

      <InputProperty
        name="DataInput"
        command="SetInputConnection"
        port_index="1">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>
          Set the vtkDataObject input used to convert the selection.
        </Documentation>
      </InputProperty>

      <InputProperty
        name="Input"
        command="SetInputConnection"
        port_index="0">
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>
          Set the selection to convert.
        </Documentation>
      </InputProperty>

      <IntVectorProperty
        name="OutputType"
        command="SetOutputType"
        number_of_elements="1"
        default_values="5">
        <Documentation>
          Set the ContentType for the output.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry value="0" text="SELECTIONS" />
          <Entry value="1" text="GLOBALIDs" />
          <Entry value="2" text="PEDIGREEIDS" />
          <Entry value="3" text="VALUES" />
          <Entry value="4" text="INDICES" />
          <Entry value="5" text="FRUSTUM" />
          <Entry value="6" text="LOCATION" />
          <Entry value="7" text="THRESHOLDS" />
        </EnumerationDomain>
      </IntVectorProperty>

      <StringVectorProperty
        name="ArrayNames"
        command="AddArrayName"
        clean_command="ClearArrayNames"
        repeat_command="1"
        number_of_elements_per_command="1"
        element_types="2"/>

      <IntVectorProperty
        name="MatchAnyValues"
        command="SetMatchAnyValues"
        number_of_elements="1"
        default_values="0">
       <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <!-- End of ConvertSelection -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="MergeBlocks"
      class="vtkCompositeDataToUnstructuredGridFilter"
      label="Merge Blocks">
      <Documentation
        short_help="Appends vtkCompositeDataSet leaves into a single vtkUnstructuredGrid" >
      vtkCompositeDataToUnstructuredGridFilter appends all vtkDataSet
      leaves of the input composite dataset to a single unstructure grid. The
      subtree to be combined can be choosen using the SubTreeCompositeIndex. If
      the SubTreeCompositeIndex is a leaf node, then no appending is required.
      </Documentation>

      <InputProperty name="Input"
        command="SetInputConnection">
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>
          Set the input composite dataset.
        </Documentation>
      </InputProperty>

      <IntVectorProperty name="SubTreeCompositeIndex"
        command="SetSubTreeCompositeIndex"
        number_of_elements="1"
        default_values="0"
        is_internal="1">
        <CompositeTreeDomain name="tree" mode="all">
           <RequiredProperties>
              <Property name="Input" function="Input"/>
           </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>
          Select the index of the subtree to be appended.
          For now, this property is internal.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MergePoints"
        label="Merge Points"
        command="SetMergePoints"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <!-- End of MergeBlocks -->
    </SourceProxy>

   <!-- ==================================================================== -->
    <CompoundSourceProxy name="NormalGlyphs" label="Normal Glyphs">
      <Documentation short_help="Filter computing surface normals."
        long_help="Filter computing surface normals.">
        Filter computing surface normals.
      </Documentation>
      <Proxy group="filters" type="DataSetSurfaceFilter" id="1013" servers="1" compound_name="ExtractSurface2">
        <Property name="Input" id="1013.Input" number_of_elements="1">
          <Domain name="groups" id="1013.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_type" id="1013.Input.input_type">
            <DataType value="vtkDataSet"/>
          </Domain>
        </Property>
        <Property name="PieceInvariant" id="1013.PieceInvariant" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="1013.PieceInvariant.bool"/>
        </Property>
      </Proxy>
      <Proxy group="filters" type="PolyDataNormals" id="1224" servers="1" compound_name="GenerateSurfaceNormals1">
        <Property name="ComputeCellNormals" id="1224.ComputeCellNormals" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="1224.ComputeCellNormals.bool"/>
        </Property>
        <Property name="Consistency" id="1224.Consistency" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="1224.Consistency.bool"/>
        </Property>
        <Property name="FeatureAngle" id="1224.FeatureAngle" number_of_elements="1">
          <Element index="0" value="30"/>
          <Domain name="range" id="1224.FeatureAngle.range">
            <Min index="0" value="0"/>
            <Max index="0" value="180"/>
          </Domain>
        </Property>
        <Property name="FlipNormals" id="1224.FlipNormals" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="bool" id="1224.FlipNormals.bool"/>
        </Property>
        <Property name="Input" id="1224.Input" number_of_elements="1">
          <Proxy value="1013" output_port="0"/>
          <Domain name="groups" id="1224.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_type" id="1224.Input.input_type">
            <DataType value="vtkPolyData"/>
          </Domain>
        </Property>
        <Property name="NonManifoldTraversal" id="1224.NonManifoldTraversal" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="1224.NonManifoldTraversal.bool"/>
        </Property>
        <Property name="PieceInvariant" id="1224.PieceInvariant" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="1224.PieceInvariant.bool"/>
        </Property>
        <Property name="Splitting" id="1224.Splitting" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="bool" id="1224.Splitting.bool"/>
        </Property>
      </Proxy>
      <Proxy group="filters" type="CellCenters" id="3392" servers="1" compound_name="CellCenters1">
        <Property name="Input" id="3392.Input" number_of_elements="1">
          <Proxy value="1224" output_port="0"/>
          <Domain name="groups" id="3392.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_type" id="3392.Input.input_type">
            <DataType value="vtkDataSet"/>
          </Domain>
        </Property>
        <Property name="VertexCells" id="3392.VertexCells" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="3392.VertexCells.bool"/>
        </Property>
      </Proxy>
      <Proxy group="filters" type="Glyph" id="2429" servers="1" compound_name="Glyph1">
        <Property name="Input" id="2429.Input" number_of_elements="1">
          <Proxy value="3392" output_port="0"/>
          <Domain name="groups" id="2429.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_array1" id="2429.Input.input_array1">
            <InputArray attribute_type="point" number_of_components="1"/>
          </Domain>
          <Domain name="input_array2" id="2429.Input.input_array2">
            <InputArray attribute_type="point" number_of_components="3"/>
          </Domain>
          <Domain name="input_type" id="2429.Input.input_type">
            <DataType value="vtkDataSet"/>
          </Domain>
        </Property>
        <Property name="MaximumNumberOfPoints" id="2429.MaximumNumberOfPoints" number_of_elements="1">
          <Element index="0" value="5000"/>
          <Domain name="range" id="2429.MaximumNumberOfPoints.range">
            <Min index="0" value="0"/>
          </Domain>
        </Property>
        <Property name="RandomMode" id="2429.RandomMode" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="2429.RandomMode.bool"/>
        </Property>
        <Property name="SelectInputScalars" id="2429.SelectInputScalars" number_of_elements="5">
          <Element index="0" value=""/>
          <Element index="1" value=""/>
          <Element index="2" value=""/>
          <Element index="3" value=""/>
          <Element index="4" value=""/>
          <Domain name="array_list" id="2429.SelectInputScalars.array_list"/>
        </Property>
        <Property name="SelectInputVectors" id="2429.SelectInputVectors" number_of_elements="5">
          <Element index="0" value="1"/>
          <Element index="1" value=""/>
          <Element index="2" value=""/>
          <Element index="3" value=""/>
          <Element index="4" value="Normals"/>
          <Domain name="array_list" id="2429.SelectInputVectors.array_list">
            <String text="Normals"/>
          </Domain>
        </Property>
        <Property name="SetOrient" id="2429.SetOrient" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="2429.SetOrient.bool"/>
        </Property>
        <Property name="SetScaleFactor" id="2429.SetScaleFactor" number_of_elements="1">
          <Element index="0" value="1.0"/>
          <Domain name="bounds" id="2429.SetScaleFactor.bounds">
            <Min index="0" value="0"/>
            <Max index="0" value="1.0"/>
          </Domain>
          <Domain name="scalar_range" id="2429.SetScaleFactor.scalar_range"/>
          <Domain name="vector_range" id="2429.SetScaleFactor.vector_range">
            <Min index="0" value="0"/>
            <Min index="1" value="0"/>
            <Min index="2" value="1"/>
            <Min index="3" value="1"/>
            <Max index="0" value="0"/>
            <Max index="1" value="0"/>
            <Max index="2" value="1"/>
            <Max index="3" value="1"/>
          </Domain>
        </Property>
        <Property name="SetScaleMode" id="2429.SetScaleMode" number_of_elements="1">
          <Element index="0" value="3"/>
          <Domain name="enum" id="2429.SetScaleMode.enum">
            <Entry value="0" text="scalar"/>
            <Entry value="1" text="vector"/>
            <Entry value="2" text="vector_components"/>
            <Entry value="3" text="off"/>
          </Domain>
        </Property>
        <Property name="Source" id="2429.Source" number_of_elements="1">
          <Proxy value="2432" output_port="0"/>
          <Domain name="groups" id="2429.Source.groups">
            <Group value="sources"/>
            <Group value="glyph_sources"/>
          </Domain>
          <Domain name="input_type" id="2429.Source.input_type">
            <DataType value="vtkPolyData"/>
          </Domain>
          <Domain name="proxy_list" id="2429.Source.proxy_list">
            <Proxy value="2432"/>
          </Domain>
        </Property>
        <Property name="UseMaskPoints" id="2429.UseMaskPoints" number_of_elements="1">
          <Element index="0" value="1"/>
          <Domain name="bool" id="2429.UseMaskPoints.bool"/>
        </Property>
      </Proxy>
      <Proxy group="sources" type="ArrowSource" id="2432" servers="1" compound_name="ArrowSource">
        <Property name="ShaftRadius" id="2432.ShaftRadius" number_of_elements="1">
          <Element index="0" value="0.03"/>
          <Domain name="range" id="2432.ShaftRadius.range">
            <Min index="0" value="0"/>
            <Max index="0" value="5"/>
          </Domain>
        </Property>
        <Property name="ShaftResolution" id="2432.ShaftResolution" number_of_elements="1">
          <Element index="0" value="6"/>
          <Domain name="range" id="2432.ShaftResolution.range">
            <Min index="0" value="0"/>
            <Max index="0" value="128"/>
          </Domain>
        </Property>
        <Property name="TipLength" id="2432.TipLength" number_of_elements="1">
          <Element index="0" value="0.35"/>
          <Domain name="range" id="2432.TipLength.range">
            <Min index="0" value="0"/>
            <Max index="0" value="1"/>
          </Domain>
        </Property>
        <Property name="TipRadius" id="2432.TipRadius" number_of_elements="1">
          <Element index="0" value="0.1"/>
          <Domain name="range" id="2432.TipRadius.range">
            <Min index="0" value="0"/>
            <Max index="0" value="10"/>
          </Domain>
        </Property>
        <Property name="TipResolution" id="2432.TipResolution" number_of_elements="1">
          <Element index="0" value="6"/>
          <Domain name="range" id="2432.TipResolution.range">
            <Min index="0" value="1"/>
            <Max index="0" value="128"/>
          </Domain>
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property name="MaximumNumberOfPoints" proxy_name="Glyph1" exposed_name="Glyph Max. Points"/>
        <Property name="RandomMode" proxy_name="Glyph1" exposed_name="Glyph Random Mode"/>
        <Property name="SetScaleFactor" proxy_name="Glyph1" exposed_name="Glyph Scale Factor"/>
        <Property name="Consistency" proxy_name="GenerateSurfaceNormals1" exposed_name="Consistency"/>
        <Property name="Input" proxy_name="ExtractSurface2" exposed_name="Input"/>
        <Property name="Invert" proxy_name="ArrowSource" exposed_name="InvertArrow"/>
      </ExposedProperties>
      <OutputPort name="Output" proxy="Glyph1" port_index="0"/>
      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
             visibility of this filter (or its input) on creation.
             replace_input="0" implies that the input visibility is not
             changed on creation of this filter (defaults to "1")
             -->
        <Visibility replace_input="0" />
      </Hints>
    </CompoundSourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy name="TableToPolyData"
                class="vtkTableToPolyData"
                label="Table To Points" >
      <Documentation short_help="Converts table to set of points."
        long_help="Converts table to set of points." >
        The TableToPolyData filter converts a vtkTable to a set of points in a
        vtkPolyData. One must specifies the columns in the input table to use as
        the X, Y and Z coordinates for the points in the output.
      </Documentation>
      <InputProperty name="Input"
         command="SetInputConnection">
            <ProxyGroupDomain name="groups">
              <Group name="sources"/>
              <Group name="filters"/>
            </ProxyGroupDomain>
            <InputArrayDomain name="input_array"
              attribute_type="row"
              number_of_components="1" />
            <DataTypeDomain name="input_type">
              <DataType value="vtkTable"/>
            </DataTypeDomain>
            <Documentation>
              This property specifies the input..
            </Documentation>
      </InputProperty>

      <StringVectorProperty name="XColumn"
        command="SetXColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            X coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>
      <StringVectorProperty name="YColumn"
        command="SetYColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list" >
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            Y coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>
      <StringVectorProperty name="ZColumn"
        command="SetZColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list" >
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            Z coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>

    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy name="TableToStructuredGrid"
                class="vtkPTableToStructuredGrid"
                label="Table To Structured Grid" >
      <Documentation
        short_help="Converts to table to structured grid."
        long_help="Converts to table to structured grid." >
        The TableToStructuredGrid filter converts a vtkTable to a
        vtkStructuredGrid.  One must specifies the columns in the input table to
        use as the X, Y and Z coordinates for the points in the output, and the
        whole extent.
      </Documentation>
      <InputProperty name="Input"
         command="SetInputConnection">
            <ProxyGroupDomain name="groups">
              <Group name="sources"/>
              <Group name="filters"/>
            </ProxyGroupDomain>
            <InputArrayDomain name="input_array"
              attribute_type="row"
              number_of_components="1" />
            <DataTypeDomain name="input_type">
              <DataType value="vtkTable"/>
            </DataTypeDomain>
            <Documentation>
              This property specifies the input..
            </Documentation>
      </InputProperty>

      <IntVectorProperty name="WholeExtent"
         command="SetWholeExtent"
         number_of_elements="6"
         default_values="0 0 0 0 0 0">
         <!--
        <ExtentDomain name="extent">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ExtentDomain>
        <Documentation>
          This property gives the minimum and maximum point index (extent) in
          each dimension for the output dataset.
        </Documentation>
        -->
      </IntVectorProperty>

      <StringVectorProperty name="XColumn"
        command="SetXColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list">
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            X coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>
      <StringVectorProperty name="YColumn"
        command="SetYColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list" >
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            Y coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>
      <StringVectorProperty name="ZColumn"
        command="SetZColumn"
        number_of_elements="1">
          <ArrayListDomain name="array_list" >
            <RequiredProperties>
              <Property name="Input" function="Input"/>
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            This property specifies which data array is going to be used as the
            Z coordinate in the generated polydata dataset.
          </Documentation>
      </StringVectorProperty>

    </SourceProxy>

    <!-- ================================================================== -->
    <SourceProxy name="TableFFT" class="vtkTableFFT" label="Table FFT">
      <Documentation>
        Performs the Fast Fourier Transform on the columns of a table.
      </Documentation>

      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <InputArrayDomain name="input_array"
                          attribute_type="row"
                          number_of_components="1" />
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- ================================================================== -->
    <CompoundSourceProxy name="FFTSelectionOverTime"
                         label="FFT Of Selection Over Time">
      <Documentation
        short_help="Extracts selection over time and plots the FFT"
        long_help="Extracts selection over time and plots the FFT" >
        Extracts the data of a selection (e.g. points or cells) over time,
        takes the FFT of them, and plots them.
      </Documentation>
      <Proxy group="filters" type="ExtractSelectionOverTime" id="734" servers="1" compound_name="PlotSelectionOverTime1">
        <Property name="Input" id="734.Input" number_of_elements="1">
          <Domain name="groups" id="734.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_type" id="734.Input.input_type">
            <DataType value="vtkDataSet"/>
            <DataType value="vtkCompositeDataSet"/>
          </Domain>
        </Property>
        <Property name="Selection" id="734.Selection" number_of_elements="1">
          <Proxy value="742" output_port="0"/>
          <Domain name="groups" id="734.Selection.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_type" id="734.Selection.input_type">
            <DataType value="vtkSelection"/>
          </Domain>
        </Property>
      </Proxy>
      <Proxy group="filters" type="TableFFT" id="812" servers="1" compound_name="TableFFT1">
        <Property name="Input" id="812.Input" number_of_elements="1">
          <Proxy value="734" output_port="0"/>
          <Domain name="groups" id="812.Input.groups">
            <Group value="sources"/>
            <Group value="filters"/>
          </Domain>
          <Domain name="input_array" id="812.Input.input_array">
            <InputArray attribute_type="row" number_of_components="1"/>
          </Domain>
          <Domain name="input_type" id="812.Input.input_type">
            <DataType value="vtkTable"/>
          </Domain>
        </Property>
      </Proxy>
      <Proxy group="sources" type="CompositeDataIDSelectionSource" id="742" servers="1" compound_name="auto_742">
        <Property name="ContainingCells" id="742.ContainingCells" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="bool" id="742.ContainingCells.bool"/>
        </Property>
        <Property name="FieldType" id="742.FieldType" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="enum" id="742.FieldType.enum">
            <Entry value="0" text="CELL"/>
            <Entry value="1" text="POINT"/>
            <Entry value="2" text="FIELD"/>
            <Entry value="3" text="VERTEX"/>
            <Entry value="4" text="EDGE"/>
          </Domain>
        </Property>
        <Property name="IDs" id="742.IDs" number_of_elements="3">
          <Element index="0" value="2"/>
          <Element index="1" value="-1"/>
          <Element index="2" value="3892"/>
        </Property>
        <Property name="InsideOut" id="742.InsideOut" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="bool" id="742.InsideOut.bool"/>
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property name="Input" proxy_name="PlotSelectionOverTime1" exposed_name="Input"/>
        <Property name="Selection" proxy_name="PlotSelectionOverTime1" exposed_name="Selection"/>
      </ExposedProperties>
      <OutputPort name="Output" proxy="TableFFT1" port_index="0"/>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
      </Hints>
    </CompoundSourceProxy> <!-- FFTSelectionOverTime -->

    <!-- ================================================================== -->
    <SourceProxy name="AttributeDataToTableFilter"
      class="vtkAttributeDataToTableFilter"
      label="Extract Attributes">
      <Documentation
        short_help="Extract attribute data as a table."
        long_help="Extract attribute data as a table.">
        This is a filter that produces a vtkTable from the chosen attribute in
        the input dataobject. This filter can accept composite datasets. If the
        input is a composite dataset, the output is a multiblock with vtkTable
        leaves.
      </Documentation>
      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>

      <IntVectorProperty name="FieldAssociation"
        command="SetFieldAssociation"
        number_of_elements="1"
        default_values="0">
        <Documentation>
          Select the attribute data to pass.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Points" value="0" />
          <Entry text="Cells" value="1" />
          <Entry text="Field Data" value="2" />
          <Entry text="Vertices" value="4" />
          <Entry text="Edges" value="5" />
          <Entry text="Rows" value="6" />
        </EnumerationDomain>
      </IntVectorProperty>

      <IntVectorProperty name="AddMetaData"
        command="SetAddMetaData"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          It is possible for this filter to add additional meta-data to the
          field data such as point coordinates (when point attributes are
          selected and input is pointset) or structured coordinates etc. To
          enable this addition of extra information, turn this flag on. Off by
          default.
        </Documentation>
      </IntVectorProperty>
      <!-- End of AttributeDataToTableFilter -->
    </SourceProxy>

    <!-- ================================================================== -->
    <SourceProxy name="PlotAttributes" label="Plot Data"
      class="vtkPassThrough">
      <Documentation short_help="Plot data arrays from the input">
        This filter prepare arbitrary data to be plotted in any of the plots.
        By default the data is shown in a XY line plot.
      </Documentation>

      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>
          The input.
        </Documentation>
      </InputProperty>
      <Hints>
        <View type="XYChartView" />
        <Plotable/>
      </Hints>
      <!-- End of PlotAttributes -->
    </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy
       name="ContingencyStatistics"
       class="vtkPSciVizContingencyStats"
       label="Contingency Statistics">
     <Documentation
       short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
       long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model." >
       This filter either computes a statistical model of a dataset or takes such a model as its second input.  Then, the model (however it is obtained) may optionally be used to assess the input dataset.
       This filter computes contingency tables between pairs of attributes.  This result is a tabular bivariate probability distribution which serves as a Bayesian-style prior model.  Data is assessed by computing &lt;ul&gt;
       &lt;li&gt; the probability of observing both variables simultaneously;
       &lt;li&gt; the probability of each variable conditioned on the other (the two values need not be identical); and
       &lt;li&gt; the pointwise mutual information (PMI). &lt;/ul&gt;
       Finally, the summary statistics include the information entropy of the observations.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection" port_index="0">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkImageData"/>
         <DataType value="vtkStructuredGrid"/>
         <DataType value="vtkPolyData"/>
         <DataType value="vtkUnstructuredGrid"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkGraph"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"/>
       <Documentation>
         The input to the filter.  Arrays from this dataset will be used for computing statistics and/or assessed by a statistical model.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="ModelInput"
         command="SetInputConnection"
         port_index="1"
         null_on_empty="1">
       <Hints>
         <Optional/> <!-- No input selection dialog at instantiation -->
       </Hints>
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkTable"/>
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         A previously-calculated model with which to assess a separate dataset. This input is optional.
       </Documentation>
     </InputProperty>

     <IntVectorProperty name="AttributeMode"
         command="SetAttributeMode"
         number_of_elements="1"
         default_values="0">
       <FieldDataDomain name="enum"
           enable_field_data="1">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Specify which type of field data the arrays will be drawn from.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
       name="SelectArrays"
       label="Variables of Interest"
       command="EnableAttributeArray"
       clean_command="ClearAttributeArrays"
       repeat_command="1"
       number_of_elements_per_command="1">
       <ArrayListDomain name="array_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
           <Property name="AttributeMode" function="FieldDataSelection"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Documentation>
         Choose arrays whose entries will be used to form observations for statistical analysis.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="Task"
         command="SetTask"
         animateable="0"
         number_of_elements="1"
         default_values="3">
       <EnumerationDomain name="task_list">
         <Entry value="0" text="Detailed model of input data"/>
         <Entry value="1" text="Model a subset of the data"/>
         <Entry value="2" text="Assess the data with a model"/>
         <Entry value="3" text="Model and assess the same data"/>
       </EnumerationDomain>
       <Documentation>
         Specify the task to be performed: modeling and/or assessment. &lt;ol&gt;
         &lt;li&gt; "Detailed model of input data," creates a set of output tables containing a calculated statistical model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
         &lt;li&gt; "Model a subset of the data," creates an output table (or tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the input dataset;&lt;/li&gt;
         &lt;li&gt; "Assess the data with a model," adds attributes to the first input dataset using a model provided on the second input port; and&lt;/li&gt;
         &lt;li&gt; "Model and assess the same data," is really just operations 2 and 3 above applied to the same input dataset.  The model is first trained using a fraction of the input data and then the entire dataset is assessed using that model.&lt;/li&gt;
         &lt;/ol&gt;
         When the task includes creating a model (i.e., tasks 2, and 4), you may adjust the fraction of the input dataset used for training.  You should avoid using a large fraction of the input data for training as you will then not be able to detect overfitting.  The &lt;i&gt;Training fraction&lt;/i&gt; setting will be ignored for tasks 1 and 3.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="TrainingFraction"
         command="SetTrainingFraction"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="training_range" min="0" max="1"/>
       <Documentation>
         Specify the fraction of values from the input dataset to be used for model fitting. The exact set of values is chosen at random from the dataset.
       </Documentation>
     </DoubleVectorProperty>

    <OutputPort name="Statistical Model" index="0"/>
    <OutputPort name="Assessed Data" index="1"/>
    <Hints>
      <Visibility replace_input="1" />
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="SpreadSheetView" />
    </Hints>

   </SourceProxy> <!-- ContingencyStatistics -->

   <!-- ==================================================================== -->
   <SourceProxy
       name="DescriptiveStatistics"
       class="vtkPSciVizDescriptiveStats"
       label="Descriptive Statistics">
     <Documentation
       short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
       long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model." >
       This filter either computes a statistical model of a dataset or takes such a model as its second input.  Then, the model (however it is obtained) may optionally be used to assess the input dataset.&lt;p&gt;
       This filter computes the min, max, mean, raw moments M2 through M4, standard deviation, skewness, and kurtosis for each array you select.&lt;p&gt;
       The model is simply a univariate Gaussian distribution with the mean and standard deviation provided. Data is assessed using this model by detrending the data (i.e., subtracting the mean) and then dividing by the standard deviation. Thus the assessment is an array whose entries are the number of standard deviations from the mean that each input point lies.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection" port_index="0">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkImageData"/>
         <DataType value="vtkStructuredGrid"/>
         <DataType value="vtkPolyData"/>
         <DataType value="vtkUnstructuredGrid"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkGraph"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"/>
       <Documentation>
         The input to the filter.  Arrays from this dataset will be used for computing statistics and/or assessed by a statistical model.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="ModelInput"
         command="SetInputConnection"
         port_index="1"
         null_on_empty="1">
       <Hints>
         <Optional/> <!-- No input selection dialog at instantiation -->
       </Hints>
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkTable"/>
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         A previously-calculated model with which to assess a separate dataset.  This input is optional.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectArrayInfo" information_only="1">
       <ArraySelectionInformationHelper attribute_name="Attribute"/> <!-- attribute_name => GetNumberOf___Arrays -->
     </StringVectorProperty>

     <IntVectorProperty name="AttributeMode"
         command="SetAttributeMode"
         number_of_elements="1"
         default_values="0">
       <FieldDataDomain name="enum"
           enable_field_data="1">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Specify which type of field data the arrays will be drawn from.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
       name="SelectArrays"
       label="Variables of Interest"
       command="EnableAttributeArray"
       clean_command="ClearAttributeArrays"
       repeat_command="1"
       number_of_elements_per_command="1">
       <ArrayListDomain name="array_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
           <Property name="AttributeMode" function="FieldDataSelection"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Documentation>
         Choose arrays whose entries will be used to form observations for statistical analysis.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="Task"
         command="SetTask"
         animateable="0"
         number_of_elements="1"
         default_values="3">
       <EnumerationDomain name="task_list">
         <Entry value="0" text="Detailed model of input data"/>
         <Entry value="1" text="Model a subset of the data"/>
         <Entry value="2" text="Assess the data with a model"/>
         <Entry value="3" text="Model and assess the same data"/>
       </EnumerationDomain>
       <Documentation>
         Specify the task to be performed: modeling and/or assessment. &lt;ol&gt;
         &lt;li&gt; "Detailed model of input data," creates a set of output tables containing a calculated statistical model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
         &lt;li&gt; "Model a subset of the data," creates an output table (or tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the input dataset;&lt;/li&gt;
         &lt;li&gt; "Assess the data with a model," adds attributes to the first input dataset using a model provided on the second input port; and&lt;/li&gt;
         &lt;li&gt; "Model and assess the same data," is really just operations 2 and 3 above applied to the same input dataset.  The model is first trained using a fraction of the input data and then the entire dataset is assessed using that model.&lt;/li&gt;
         &lt;/ol&gt;
         When the task includes creating a model (i.e., tasks 2, and 4), you may adjust the fraction of the input dataset used for training.  You should avoid using a large fraction of the input data for training as you will then not be able to detect overfitting.  The &lt;i&gt;Training fraction&lt;/i&gt; setting will be ignored for tasks 1 and 3.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="TrainingFraction"
         command="SetTrainingFraction"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="training_range" min="0" max="1"/>
       <Documentation>
         Specify the fraction of values from the input dataset to be used for model fitting. The exact set of values is chosen at random from the dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty name="SignedDeviations"
         command="SetSignedDeviations"
         label="Deviations should be"
         animateable="1"
         number_of_elements="1"
         default_values="0">
       <EnumerationDomain name="signed_distance">
         <Entry value="0" text="Unsigned"/>
         <Entry value="1" text="Signed"/>
       </EnumerationDomain>
       <Documentation>
         Should the assessed values be signed deviations or unsigned?
       </Documentation>
     </IntVectorProperty>

    <OutputPort name="Statistical Model" index="0"/>
    <OutputPort name="Assessed Data" index="1"/>
    <Hints>
      <Visibility replace_input="1" />
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="SpreadSheetView" />
    </Hints>

   </SourceProxy> <!-- DescriptiveStatistics -->

   <!-- ==================================================================== -->
   <SourceProxy
       name="KMeans"
       class="vtkPSciVizKMeans"
       label="K Means">
     <Documentation
       short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
       long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model." >
       This filter either computes a statistical model of a dataset or takes such a model as its second input.  Then, the model (however it is obtained) may optionally be used to assess the input dataset.&lt;p&gt;
       This filter iteratively computes the center of k clusters in a space whose coordinates are specified by the arrays you select. The clusters are chosen as local minima of the sum of square Euclidean distances from each point to its nearest cluster center. The model is then a set of cluster centers. Data is assessed by assigning a cluster center and distance to the cluster to each point in the input data set.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection" port_index="0">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkImageData"/>
         <DataType value="vtkStructuredGrid"/>
         <DataType value="vtkPolyData"/>
         <DataType value="vtkUnstructuredGrid"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkGraph"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"/>
       <Documentation>
         The input to the filter.  Arrays from this dataset will be used for computing statistics and/or assessed by a statistical model.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="ModelInput"
         command="SetInputConnection"
         port_index="1"
         null_on_empty="1">
       <Hints>
         <Optional/> <!-- No input selection dialog at instantiation -->
       </Hints>
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkTable"/>
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         A previously-calculated model with which to assess a separate dataset. This input is optional.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectArrayInfo" information_only="1">
       <ArraySelectionInformationHelper attribute_name="Attribute"/> <!-- attribute_name => GetNumberOf___Arrays -->
     </StringVectorProperty>

     <IntVectorProperty name="AttributeMode"
         command="SetAttributeMode"
         number_of_elements="1"
         default_values="0">
       <FieldDataDomain name="enum"
           enable_field_data="1">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Specify which type of field data the arrays will be drawn from.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
       name="SelectArrays"
       label="Variables of Interest"
       command="EnableAttributeArray"
       clean_command="ClearAttributeArrays"
       repeat_command="1"
       number_of_elements_per_command="1">
       <ArrayListDomain name="array_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
           <Property name="AttributeMode" function="FieldDataSelection"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Documentation>
         Choose arrays whose entries will be used to form observations for statistical analysis.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="Task"
         command="SetTask"
         animateable="0"
         number_of_elements="1"
         default_values="3">
       <EnumerationDomain name="task_list">
         <Entry value="0" text="Detailed model of input data"/>
         <Entry value="1" text="Model a subset of the data"/>
         <Entry value="2" text="Assess the data with a model"/>
         <Entry value="3" text="Model and assess the same data"/>
       </EnumerationDomain>
       <Documentation>
         Specify the task to be performed: modeling and/or assessment. &lt;ol&gt;
         &lt;li&gt; "Detailed model of input data," creates a set of output tables containing a calculated statistical model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
         &lt;li&gt; "Model a subset of the data," creates an output table (or tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the input dataset;&lt;/li&gt;
         &lt;li&gt; "Assess the data with a model," adds attributes to the first input dataset using a model provided on the second input port; and&lt;/li&gt;
         &lt;li&gt; "Model and assess the same data," is really just operations 2 and 3 above applied to the same input dataset.  The model is first trained using a fraction of the input data and then the entire dataset is assessed using that model.&lt;/li&gt;
         &lt;/ol&gt;
         When the task includes creating a model (i.e., tasks 2, and 4), you may adjust the fraction of the input dataset used for training.  You should avoid using a large fraction of the input data for training as you will then not be able to detect overfitting.  The &lt;i&gt;Training fraction&lt;/i&gt; setting will be ignored for tasks 1 and 3.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="TrainingFraction"
         command="SetTrainingFraction"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="training_range" min="0" max="1"/>
       <Documentation>
         Specify the fraction of values from the input dataset to be used for model fitting. The exact set of values is chosen at random from the dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty name="K"
         label="k"
         command="SetK"
         animateable="1"
         number_of_elements="1"
         default_values="5">
       <IntRangeDomain name="num_cluster_centers" min="1"/>
       <Documentation>
         Specify the number of clusters.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="MaxNumIterations"
         label="Max Iterations"
         command="SetMaxNumIterations"
         animateable="1"
         number_of_elements="1"
         default_values="50">
       <IntRangeDomain name="max_num_iter" min="1"/>
       <Documentation>
         Specify the maximum number of iterations in which cluster centers are moved before the algorithm terminates.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="Tolerance"
         command="SetTolerance"
         animateable="1"
         number_of_elements="1"
         default_values="0.01">
       <DoubleRangeDomain name="cluster_center_tolerance" min="0" max="1"/>
       <Documentation>
         Specify the relative tolerance that will cause early termination.
       </Documentation>
     </DoubleVectorProperty>

    <OutputPort name="Statistical Model" index="0"/>
    <OutputPort name="Assessed Data" index="1"/>
    <Hints>
      <Visibility replace_input="1" />
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="SpreadSheetView" />
    </Hints>

   </SourceProxy> <!-- K Means -->

   <!-- ==================================================================== -->
   <SourceProxy
       name="MulticorrelativeStatistics"
       class="vtkPSciVizMultiCorrelativeStats"
       label="Multicorrelative Statistics">
     <Documentation
       short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
       long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model." >
       This filter either computes a statistical model of a dataset or takes such a model as its second input. Then, the model (however it is obtained) may optionally be used to assess the input dataset.&lt;p&gt;
       This filter computes the covariance matrix for all the arrays you select plus the mean of each array. The model is thus a multivariate Gaussian distribution with the mean vector and variances provided. Data is assessed using this model by computing the Mahalanobis distance for each input point. This distance will always be positive.&lt;p&gt;
       The learned model output format is rather dense and can be confusing, so it is discussed here. The first filter output is a multiblock dataset consisting of 2 tables: &lt;ol&gt;
       &lt;li&gt; Raw covariance data.
       &lt;li&gt; Covariance matrix and its Cholesky decomposition. &lt;/ol&gt;
       The raw covariance table has 3 meaningful columns: 2 titled "Column1" and "Column2" whose entries generally refer to the N arrays you selected when preparing the filter and 1 column titled "Entries" that contains numeric values. The first row will always contain the number of observations in the statistical analysis. The next N rows contain the mean for each of the N arrays you selected. The remaining rows contain covariances of pairs of arrays.&lt;p&gt;
       The second table (covariance matrix and Cholesky decomposition) contains information derived from the raw covariance data of the first table. The first N rows of the first column contain the name of one array you selected for analysis. These rows are followed by a single entry labeled "Cholesky" for a total of N+1 rows. The second column, Mean contains the mean of each variable in the first N entries and the number of observations processed in the final (N+1) row.&lt;p&gt;
       The remaining columns (there are N, one for each array) contain 2 matrices in triangular format. The upper right triangle contains the covariance matrix (which is symmetric, so its lower triangle may be inferred). The lower left triangle contains the Cholesky decomposition of the covariance matrix (which is triangular, so its upper triangle is zero). Because the diagonal must be stored for both matrices, an additional row is required — hence the N+1 rows and the final entry of the column named "Column".
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection" port_index="0">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkImageData"/>
         <DataType value="vtkStructuredGrid"/>
         <DataType value="vtkPolyData"/>
         <DataType value="vtkUnstructuredGrid"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkGraph"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"/>
       <Documentation>
         The input to the filter. Arrays from this dataset will be used for computing statistics and/or assessed by a statistical model.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="ModelInput"
         command="SetInputConnection"
         port_index="1"
         null_on_empty="1">
       <Hints>
         <Optional/> <!-- No input selection dialog at instantiation -->
       </Hints>
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkTable"/>
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         A previously-calculated model with which to assess a separate dataset. This input is optional.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectArrayInfo" information_only="1">
       <ArraySelectionInformationHelper attribute_name="Attribute"/> <!-- attribute_name => GetNumberOf___Arrays -->
     </StringVectorProperty>

     <IntVectorProperty name="AttributeMode"
         command="SetAttributeMode"
         number_of_elements="1"
         default_values="0">
       <FieldDataDomain name="enum"
           enable_field_data="1">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Specify which type of field data the arrays will be drawn from.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
       name="SelectArrays"
       label="Variables of Interest"
       command="EnableAttributeArray"
       clean_command="ClearAttributeArrays"
       repeat_command="1"
       number_of_elements_per_command="1">
       <ArrayListDomain name="array_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
           <Property name="AttributeMode" function="FieldDataSelection"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Documentation>
         Choose arrays whose entries will be used to form observations for statistical analysis.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="Task"
         command="SetTask"
         animateable="0"
         number_of_elements="1"
         default_values="3">
       <EnumerationDomain name="task_list">
         <Entry value="0" text="Detailed model of input data"/>
         <Entry value="1" text="Model a subset of the data"/>
         <Entry value="2" text="Assess the data with a model"/>
         <Entry value="3" text="Model and assess the same data"/>
       </EnumerationDomain>
       <Documentation>
         Specify the task to be performed: modeling and/or assessment. &lt;ol&gt;
         &lt;li&gt; "Detailed model of input data," creates a set of output tables containing a calculated statistical model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
         &lt;li&gt; "Model a subset of the data," creates an output table (or tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the input dataset;&lt;/li&gt;
         &lt;li&gt; "Assess the data with a model," adds attributes to the first input dataset using a model provided on the second input port; and&lt;/li&gt;
         &lt;li&gt; "Model and assess the same data," is really just operations 2 and 3 above applied to the same input dataset.  The model is first trained using a fraction of the input data and then the entire dataset is assessed using that model.&lt;/li&gt;
         &lt;/ol&gt;
         When the task includes creating a model (i.e., tasks 2, and 4), you may adjust the fraction of the input dataset used for training.  You should avoid using a large fraction of the input data for training as you will then not be able to detect overfitting.  The &lt;i&gt;Training fraction&lt;/i&gt; setting will be ignored for tasks 1 and 3.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="TrainingFraction"
         command="SetTrainingFraction"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="training_range" min="0" max="1"/>
       <Documentation>
         Specify the fraction of values from the input dataset to be used for model fitting. The exact set of values is chosen at random from the dataset.
       </Documentation>
     </DoubleVectorProperty>

    <OutputPort name="Statistical Model" index="0"/>
    <OutputPort name="Assessed Data" index="1"/>
    <Hints>
      <Visibility replace_input="1" />
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="SpreadSheetView" />
    </Hints>

   </SourceProxy> <!-- MulticorrelativeStatistics -->

   <!-- ==================================================================== -->
   <SourceProxy
       name="PCAStatistics"
       class="vtkPSciVizPCAStats"
       label="Principal Component Analysis">
     <Documentation
       short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
       long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model." >
       This filter either computes a statistical model of a dataset or takes such a model as its second input. Then, the model (however it is obtained) may optionally be used to assess the input dataset. &lt;p&gt;
       This filter performs additional analysis above and beyond the multicorrelative filter. It computes the eigenvalues and eigenvectors of the covariance matrix from the multicorrelative filter. Data is then assessed by projecting the original tuples into a possibly lower-dimensional space. &lt;p&gt;
       Since the PCA filter uses the multicorrelative filter's analysis, it shares the same raw covariance table specified in the multicorrelative documentation. The second table in the multiblock dataset comprising the model output is an expanded version of the multicorrelative version. &lt;p&gt;
       As with the multicorrlative filter, the second model table contains the mean values, the upper-triangular portion of the symmetric covariance matrix, and the non-zero lower-triangular portion of the Cholesky decomposition of the covariance matrix. Below these entries are the eigenvalues of the covariance matrix (in the column labeled "Mean") and the eigenvectors (as row vectors) in an additional NxN matrix.
     </Documentation>

     <InputProperty name="Input" command="SetInputConnection" port_index="0">
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkImageData"/>
         <DataType value="vtkStructuredGrid"/>
         <DataType value="vtkPolyData"/>
         <DataType value="vtkUnstructuredGrid"/>
         <DataType value="vtkTable"/>
         <DataType value="vtkGraph"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"/>
       <Documentation>
         The input to the filter. Arrays from this dataset will be used for computing statistics and/or assessed by a statistical model.
       </Documentation>
     </InputProperty>

     <InputProperty
         name="ModelInput"
         command="SetInputConnection"
         port_index="1"
         null_on_empty="1">
       <Hints>
         <Optional/> <!-- No input selection dialog at instantiation -->
       </Hints>
       <ProxyGroupDomain name="groups">
         <Group name="sources" />
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkTable"/>
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         A previously-calculated model with which to assess a separate dataset. This input is optional.
       </Documentation>
     </InputProperty>

     <StringVectorProperty name="SelectArrayInfo" information_only="1">
       <ArraySelectionInformationHelper attribute_name="Attribute"/> <!-- attribute_name => GetNumberOf___Arrays -->
     </StringVectorProperty>

     <IntVectorProperty name="AttributeMode"
         command="SetAttributeMode"
         number_of_elements="1"
         default_values="0">
       <FieldDataDomain name="enum"
           enable_field_data="1">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Specify which type of field data the arrays will be drawn from.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
       name="SelectArrays"
       label="Variables of Interest"
       command="EnableAttributeArray"
       clean_command="ClearAttributeArrays"
       repeat_command="1"
       number_of_elements_per_command="1">
       <ArrayListDomain name="array_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
           <Property name="AttributeMode" function="FieldDataSelection"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Documentation>
         Choose arrays whose entries will be used to form observations for statistical analysis.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty name="Task"
         command="SetTask"
         animateable="0"
         number_of_elements="1"
         default_values="3">
       <EnumerationDomain name="task_list">
         <Entry value="0" text="Detailed model of input data"/>
         <Entry value="1" text="Model a subset of the data"/>
         <Entry value="2" text="Assess the data with a model"/>
         <Entry value="3" text="Model and assess the same data"/>
       </EnumerationDomain>
       <Documentation>
         Specify the task to be performed: modeling and/or assessment. &lt;ol&gt;
         &lt;li&gt; "Detailed model of input data," creates a set of output tables containing a calculated statistical model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
         &lt;li&gt; "Model a subset of the data," creates an output table (or tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the input dataset;&lt;/li&gt;
         &lt;li&gt; "Assess the data with a model," adds attributes to the first input dataset using a model provided on the second input port; and&lt;/li&gt;
         &lt;li&gt; "Model and assess the same data," is really just operations 2 and 3 above applied to the same input dataset.  The model is first trained using a fraction of the input data and then the entire dataset is assessed using that model.&lt;/li&gt;
         &lt;/ol&gt;
         When the task includes creating a model (i.e., tasks 2, and 4), you may adjust the fraction of the input dataset used for training.  You should avoid using a large fraction of the input data for training as you will then not be able to detect overfitting.  The &lt;i&gt;Training fraction&lt;/i&gt; setting will be ignored for tasks 1 and 3.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="TrainingFraction"
         command="SetTrainingFraction"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="training_range" min="0" max="1"/>
       <Documentation>
         Specify the fraction of values from the input dataset to be used for model fitting. The exact set of values is chosen at random from the dataset.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty name="NormalizationScheme"
         label="Normalization Scheme"
         command="SetNormalizationScheme"
         animateable="1"
         number_of_elements="1"
         default_values="2">
       <EnumerationDomain name="norm_scheme">
         <Entry value="0" text="No normalization"/>
         <Entry value="3" text="Normalize using covariances"/>
       </EnumerationDomain>
       <Documentation>
         Before the eigenvector decomposition of the covariance matrix takes place, you may normalize each (i,j) entry by sqrt( cov(i,i) * cov(j,j) ). This implies that the variance of each variable of interest should be of equal importance.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="BasisScheme"
         label="Basis Scheme"
         command="SetBasisScheme"
         animateable="1"
         number_of_elements="1"
         default_values="0">
       <EnumerationDomain name="basis_scheme">
         <Entry value="0" text="Full basis"/>
         <Entry value="1" text="Fixed-size basis"/>
         <Entry value="2" text="Fixed-energy basis"/>
       </EnumerationDomain>
       <Documentation>
         When reporting assessments, should the full eigenvector decomposition be used to project the original vector into the new space (Full basis), or should a fixed subset of the decomposition be used (Fixed-size basis), or should the projection be clipped to preserve at least some fixed "energy" (Fixed-energy basis)?&lt;p&gt;

         As an example, suppose the variables of interest were {A,B,C,D,E} and that the eigenvalues of the covariance matrix for these were {5,2,1.5,1,.5}. If the "Full basis" scheme is used, then all 5 components of the eigenvectors will be used to project each {A,B,C,D,E}-tuple in the original data into a new 5-components space.&lt;p&gt;

         If the "Fixed-size" scheme is used and the "Basis Size" property is set to 4, then only the first 4 eigenvector components will be used to project each {A,B,C,D,E}-tuple into the new space and that space will be of dimension 4, not 5.&lt;p&gt;

         If the "Fixed-energy basis" scheme is used and the "Basis Energy" property is set to 0.8, then only the first 3 eigenvector components will be used to project each {A,B,C,D,E}-tuple into the new space, which will be of dimension 3. The number 3 is chosen because 3 is the lowest N for which the sum of the first N eigenvalues divided by the sum of all eigenvalues is larger than the specified "Basis Energy" (i.e., (5+2+1.5)/10 = 0.85 > 0.8).
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty name="BasisSize"
         label="Basis Size"
         command="SetFixedBasisSize"
         animateable="1"
         number_of_elements="1"
         default_values="2">
       <IntRangeDomain name="basis_size_range" min="1"/>
       <Documentation>
         The maximum number of eigenvector components to use when projecting into the new space.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty name="BasisEnergy"
         label="Basis Energy"
         command="SetFixedBasisEnergy"
         animateable="1"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="basis_energy_range" min="0" max="1"/>
       <Documentation>
         The minimum energy to use when determining the dimensionality of the new space into which the assessment will project tuples.
       </Documentation>
     </DoubleVectorProperty>

    <OutputPort name="Statistical Model" index="0"/>
    <OutputPort name="Assessed Data" index="1"/>
    <Hints>
      <Visibility replace_input="1" />
      <!-- View can be used to specify the preferred view for the proxy -->
      <View type="SpreadSheetView" />
    </Hints>

   </SourceProxy> <!-- PCAStatistics -->

   <SourceProxy name="HaloFinder" class="vtkPCosmoHaloFinder" label="FOF/SOD Halo Finder">
     <InputProperty
        name="Input"
        command="SetInputConnection">
          <ProxyGroupDomain name="groups">
            <Group name="sources"/>
            <Group name="filters"/>
          </ProxyGroupDomain>
          <DataTypeDomain name="input_type">
            <DataType value="vtkUnstructuredGrid"/>
          </DataTypeDomain>
          <Documentation>This property specifies the input of the filter.</Documentation>
     </InputProperty>

     <DoubleVectorProperty
        name="RL"
        command="SetRL"
        label="rL (physical box side length)"
        number_of_elements="1"
        default_values="100" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
       The box side length used to wrap particles around if they exceed rL (or less than 0) in any dimension (only positive positions are allowed in the input, or they are wrapped around).
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="Overlap"
        command="SetOverlap"
        label="overlap (shared point/ghost cell gap distance)"
        number_of_elements="1"
        default_values="5" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
       The space (in rL units) to extend processor particle ownership for ghost particles/cells.  Needed for correct halo calculation when halos cross processor boundaries in parallel computation.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="NP"
        command="SetNP"
        label="np (number of seeded particles in one dimension, i.e., total particles = np^3)"
        number_of_elements="1"
        default_values="256" >
     <IntRangeDomain name="range" min="0" />
       <Documentation>
        Number of seeded particles in one dimension.  Therefore, total simulation particles is np^3 (cubed).
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="BB"
        command="SetBB"
        label="bb (linking length)"
        number_of_elements="1"
        default_values="0.20" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
         Linking length measured in units of interparticle spacing and is dimensionless.  Used to link particles into halos for the friends-of-friends (FOF) algorithm.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="PMin"
        command="SetPMin"
        label="pmin (minimum particle threshold for an FOF halo)"
        number_of_elements="1"
        default_values="100" >
     <IntRangeDomain name="range" min="1" />
       <Documentation>
         Minimum number of particles (threshold) needed before a group is called a friends-of-friends (FOF) halo.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="CopyHaloDataToParticles"
        command="SetCopyHaloDataToParticles"
        label="Copy FOF halo catalog to original particles"
        number_of_elements="1"
        default_values="0" >
     <BooleanDomain name="bool" />
       <Documentation>
       If checked, the friends-of-friends (FOF) halo catalog information will be copied to the original particles as well.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeMostBoundParticle"
        command="SetComputeMostBoundParticle"
        label="Compute the most bound particle"
        number_of_elements="1"
        default_values="0" >
     <BooleanDomain name="bool" />
       <Documentation>
       If checked, the most bound particle for an FOF halo will be calculated.  WARNING: This can be very slow.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeMostConnectedParticle"
        command="SetComputeMostConnectedParticle"
        label="Compute the most connected particle"
        number_of_elements="1"
        default_values="0" >
     <BooleanDomain name="bool" />
       <Documentation>
       If checked, the most connected particle for an FOF halo will be calculated.  WARNING: This can be very slow.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="ComputeSOD"
        command="SetComputeSOD"
        label="Compute spherical overdensity (SOD) halos"
        number_of_elements="1"
        default_values="0" >
     <BooleanDomain name="bool" />
       <Documentation>
       If checked, spherical overdensity (SOD) halos will be calculated in addition to friends-of-friends (FOF) halos.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
         name="SODCenterType"
         command="SetSODCenterType"
         label="initial SOD center"
         number_of_elements="1"
         default_values="0">
       <EnumerationDomain name="sod_center_type">
         <Entry value="0" text="Center of mass"/>
         <Entry value="1" text="Average position"/>
         <Entry value="2" text="Most bound particle"/>
         <Entry value="3" text="Most connected particle"/>
       </EnumerationDomain>
       <Documentation>
       The initial friends-of-friends (FOF) center used for calculating a spherical overdensity (SOD) halo.  WARNING: Using MBP or MCP can be very slow.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="RhoC"
        command="SetRhoC"
        label="rho_c"
        number_of_elements="1"
        default_values="2.77536627e11" >
     <DoubleRangeDomain name="range" />
       <Documentation>
       rho_c (critical density) for SOD halo finding.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="SODMass"
        command="SetSODMass"
        label="initial SOD mass"
        number_of_elements="1"
        default_values="1.0e14" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
       The initial SOD mass.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="MinRadiusFactor"
        command="SetMinRadiusFactor"
        label="minimum radius factor"
        number_of_elements="1"
        default_values="0.5" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
       Minimum radius factor for SOD finding.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
        name="MaxRadiusFactor"
        command="SetMaxRadiusFactor"
        label="maximum radius factor"
        number_of_elements="1"
        default_values="2.0" >
     <DoubleRangeDomain name="range" min="0" />
       <Documentation>
       Maximum radius factor for SOD finding.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
        name="SODBins"
        command="SetSODBins"
        label="number of bins"
        number_of_elements="1"
        default_values="20" >
     <IntRangeDomain name="range" min="1" />
       <Documentation>
       Number of bins for SOD finding.
       </Documentation>
     </IntVectorProperty>

     <IntVectorProperty
        name="MinFOFSize"
        command="SetMinFOFSize"
        label="minimum FOF size"
        number_of_elements="1"
        default_values="1000" >
     <IntRangeDomain name="range" min="0" />
       <Documentation>
       Minimum FOF halo size to calculate an SOD halo.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
        name="MinFOFMass"
        command="SetMinFOFMass"
        label="minimum FOF mass"
        number_of_elements="1"
        default_values="5.0e12" >
     <DoubleRangeDomain name="range" />
       <Documentation>
       Minimum FOF mass to calculate an SOD halo.
       </Documentation>
     </DoubleVectorProperty>

   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="MaterialInterfaceFilter"
                class="vtkMaterialInterfaceFilter"
                label="Material Interface Filter">
     <Documentation
       long_help="The Material Interface filter finds volumes in the input data containg material above a certain material fraction."
       short_help="The Material Interface filter finds volumes in the input data containg material above a certain material fraction.">
       The Material Interface filter finds voxels inside of which a material
       fraction (or normalized amount of material) is higher than a given
       threshold. As these voxels are identified surfaces enclosing adjacent
       voxels above the threshold are generated. The resulting volume and its
       surface are what we call a fragment. The filter has the ability to
       compute various volumetric attributes such as fragment volume, mass,
       center of mass as well as volume and mass weighted averages for any of
       the fields present. Any field selected for such computation will be also
       be coppied into the fragment surface's point data for visualization. The
       filter also has the ability to generate Oriented Bounding Boxes (OBB) for
       each fragment.

       The data generated by the filter is organized in three outputs. The
       "geometry" output, containing the fragment surfaces. The "statistics"
       output, containing a point set of the centers of mass. The "obb
       representaion" output, containing OBB representations (poly data). All
       computed attributes are coppied into the statistics and geometry output.
       The obb representation output is used for validation and debugging
       puproses and is turned off by default.

       To measure the size of craters, the filter can invert a volume fraction
       and clip the volume fraction with a sphere and/or a plane.
     </Documentation>
     <OutputPort name="geometry" index="0" />
     <OutputPort name="statistics" index="1" />
     <InputProperty name="Input"
        command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkHierarchicalBoxDataSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array" attribute_type="cell" />
       <Documentation>
         Input to the filter can be a hierarchical box data set containing image
         data or a multi-block of rectilinear grids.
       </Documentation>
     </InputProperty>

     <!-- Material Fraction Array-->
     <StringVectorProperty name="SelectMaterialArray"
        command="SelectMaterialArray"
        clean_command="UnselectAllMaterialArrays"
        repeat_command="1"
        number_of_elements_per_command="1"
        label="Select Material Fraction Arrays">
       <ArrayListDomain name="array_list"
          data_type="VTK_UNSIGNED_CHAR" attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- override gui no to set default -->
         <!-- <NoDefault /> -->
       </Hints>
       <Documentation>
         Material fraction is defined as normalized amount of material per
         voxel. It is expected that arrays containing material fraction data has
         been down converted to a unsigned char.
       </Documentation>
     </StringVectorProperty>

     <!-- Material fraction -->
     <DoubleVectorProperty
       name="MaterialFractionThreshold"
       command="SetMaterialFractionThreshold"
       number_of_elements="1"
       default_values="0.5"
       label="Material Fraction Threshold">
       <DoubleRangeDomain name="range" min="0.08" max="1" />
       <Documentation>
         Material fraction is defined as normalized amount of material per
         voxel. Any voxel in the input data set with a material fraction greater
         than this value is included in the output data set.
       </Documentation>
     </DoubleVectorProperty>

     <!-- Invert the volume fraction -->
     <IntVectorProperty
        name="InvertVolumeFraction"
        command="SetInvertVolumeFraction"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Inverting the volume fraction generates the negative of the material.
         It is useful for analyzing craters.
       </Documentation>
     </IntVectorProperty>

     <ProxyProperty name="ClipFunction" command="SetClipFunction"
        label="Clip Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="None" />
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             This property sets the type of clip geometry, and
             associated parameters.
           </Documentation>
     </ProxyProperty>

     <!-- Mass Array-->
     <StringVectorProperty
       name="SelectMassArray"
       command="SelectMassArray"
       clean_command="UnselectAllMassArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Select Mass Arrays">
       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE"
         attribute_type="Scalars">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- override gui no to set default -->
         <NoDefault />
       </Hints>
       <Documentation>
         Mass arrays are paired with material fraction arrays. This means that
         the first selected material fraction array is paired with the first
         selected mass array, and so on sequentially. As the filter identifies
         voxels meeting the minimum material fraction threshold, these voxel's
         mass will be used in fragment center of mass and mass calculation.

         A warning is generated if no mass array is selected for an individual
         material fraction array. However, in that case the filter will run
         without issue because the statistics output can be generated using
         fragments' centers computed from axis aligned bounding boxes.
       </Documentation>
     </StringVectorProperty>

     <!-- Volume weighted average Array -->
     <StringVectorProperty
       name="SelectVolumeWtdAvgArray"
       command="SelectVolumeWtdAvgArray"
       clean_command="UnselectAllVolumeWtdAvgArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Compute volume weighted average over:">
       <Documentation>
         Specifies the arrays from which to volume weighted average.
       </Documentation>
       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- override gui no to set default -->
         <NoDefault />
       </Hints>
       <Documentation>
         For arrays selected a volume weighted average is computed. The values
         of these arrays are also coppied into fragment geometry cell data as
         the fragment surfaces are generated.
       </Documentation>
     </StringVectorProperty>

     <!-- Mass weighted average Array -->
     <StringVectorProperty
       name="SelectMassWtdAvgArray"
       command="SelectMassWtdAvgArray"
       clean_command="UnselectAllMassWtdAvgArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Compute mass weighted average over:">
       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <!-- override gui no to set default -->
         <NoDefault />
       </Hints>
       <Documentation>
         For arrays selected a mass weighted average is computed. These arrays
         are also coppied into fragment geometry cell data as the fragment
         surfaces are generated.
       </Documentation>
     </StringVectorProperty>

      <!-- do not remove -->
     <!-- Summation Array
     <StringVectorProperty
       name="SelectSummationArray"
       command="SelectSummationArray"
       clean_command="UnselectAllSummationArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Compute summation over:">
       <Documentation>
         Specifies the arrays from which to sum over fragments.
       </Documentation>

       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <NoDefault />
       </Hints>
     </StringVectorProperty>-->

     <!-- Compute OBB -->
     <IntVectorProperty
        name="ComputeOBB"
        command="SetComputeOBB"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         Compute Object Oriented Bounding boxes (OBB). When active the result of
         this computation is coppied into the statistics output. In the case
         that the filter is built in its validation mode, the OBB's are
         rendered.
       </Documentation>
     </IntVectorProperty>

     <!-- Write a csv file:
          This is not an excel compatible file, it has more
          information that is stored in headers. Also commas
          are used on tuple boundaries while spaces are used
          on component boundaries.-->
     <IntVectorProperty
        name="WriteGeometryOutput"
        command="SetWriteGeometryOutput"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set, then the geometry output is written to a text
         file. The file name will be coonstructed using the path in the "Output
         Base Name" widget.
       </Documentation>
     </IntVectorProperty>
     <IntVectorProperty
        name="WriteStatisticsOutput"
        command="SetWriteStatisticsOutput"
        number_of_elements="1"
        default_values="0" >
       <BooleanDomain name="bool"/>
       <Documentation>
         If this property is set, then the statistics output is written to a
         text file. The file name will be coonstructed using the path in the
         "Output Base Name" widget.
       </Documentation>
     </IntVectorProperty>

     <StringVectorProperty
        name="OutputBaseName"
        command="SetOutputBaseName"
        animateable="0"
        number_of_elements="1">
        <Documentation>
          This property specifies the base including path of where to write the
          statistics and gemoetry output text files. It follows the pattern
          "/path/to/folder/and/file" here file has no extention, as the filter
          will generate a unique extention.
        </Documentation>
     </StringVectorProperty>

      <!-- do not remove
      this is a feature that most users should not
      need. If memory usage becomes a problem then
      this gives the user more control over excluding
      highly loaded processes from memory intesive operations. -->
     <!-- loading bounds
     <IntVectorProperty
       name="UpperLoadingBound"
       command="SetUpperLoadingBound"
       number_of_elements="1"
       default_values="-1"
       label="Loading Bound">
       <DoubleRangeDomain name="range" min="-1" max="2000000000" />
       <Documentation>
         Bound in polygons above which process are excluded from work sharing.
       </Documentation>
     </IntVectorProperty>-->

   <!-- End MaterialInterfaceFilter -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="IntersectFragments"
                class="vtkIntersectFragments"
                label="Intersect Fragments">
     <Documentation
       long_help="The Intersect Fragments filter perform geometric intersections on sets of fragments."
       short_help="The Intersect Fragments filter perform geometric intersections on sets of fragments.">
       The Intersect Fragments filter perform geometric intersections on sets of
       fragments. The filter takes two inputs, the first containing fragment
       geometry and the second containing fragment centers. The filter has two
       outputs. The first is geometry that results from the intersection. The
       second is a set of points that is an approximation of the center of where
       each fragment has been intersected.
     </Documentation>

     <!-- Out -->
     <OutputPort name="geometry" index="0" />
     <OutputPort name="statistics" index="1" />
     <!-- In -->
     <InputProperty
       name="Input"
       command="SetGeometryInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         This input must contian fragment geometry.
       </Documentation>
     </InputProperty>
     <InputProperty
       name="Source"
       command="SetStatisticsInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkMultiBlockDataSet"/>
       </DataTypeDomain>
       <Documentation>
         This input must contian fragment centers.
       </Documentation>
     </InputProperty>
    <!-- Cut functuion -->
    <ProxyProperty name="CutFunction" command="SetCutFunction"
        label="Slice Type">
           <ProxyGroupDomain name="groups">
              <Group name="implicit_functions"/>
           </ProxyGroupDomain>
           <ProxyListDomain name="proxy_list">
              <Proxy group="implicit_functions" name="Plane" />
              <Proxy group="implicit_functions" name="Box" />
              <Proxy group="implicit_functions" name="Sphere" />
           </ProxyListDomain>
           <Documentation>
             This property sets the type of intersecting geometry, and
             associated parameters.
           </Documentation>
     </ProxyProperty>
   <!-- End IntersectFragments -->
   </SourceProxy>

   <!-- ==================================================================== -->
   <SourceProxy name="GaussianSplatter"
                class="vtkGaussianSplatter"
                label="Gaussian Resampling">
     <Documentation
         long_help="Splat points into a volume with an elliptical, Gaussian distribution."
         short_help="Point to voxel splatter.">
       vtkGaussianSplatter is a filter that injects input points into a
       structured points (volume) dataset. As each point is injected, it "splats"
       or distributes values to nearby voxels. Data is distributed using an
       elliptical, Gaussian distribution function. The distribution function is
       modified using scalar values (expands distribution) or normals
       (creates ellipsoidal distribution rather than spherical).

       Warning: results may be incorrect in parallel as points can't splat
       into other processor's cells.
     </Documentation>

     <InputProperty
         name="Input"
         command="SetInputConnection">
       <ProxyGroupDomain name="groups">
         <Group name="sources"/>
         <Group name="filters"/>
       </ProxyGroupDomain>
       <DataTypeDomain name="input_type">
         <DataType value="vtkDataSet"/>
       </DataTypeDomain>
       <InputArrayDomain name="input_array"
                         number_of_components="1"
                         attribute_type="point"/>
       <Documentation>
         This property specifies the input to the filter.
       </Documentation>
     </InputProperty>

     <StringVectorProperty
         name="SelectInputScalars"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         animateable="0"
         label="Resample Field">
       <ArrayListDomain name="array_list" attribute_type="Scalars"
                        none_string="ignore arrays">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <FieldDataDomain name="field_list">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </FieldDataDomain>
       <Documentation>
         Choose a scalar array to splat into the output cells. If ignore arrays is chosen, point density will be counted instead.
       </Documentation>
     </StringVectorProperty>

     <IntVectorProperty
         name="SampleDimensions"
         label="Resampling Grid"
         command="SetSampleDimensions"
         number_of_elements="3"
         default_values="50 50 50">
       <IntRangeDomain name="range" />
       <Documentation>
         Set / get the dimensions of the sampling structured point set. Higher values produce better results but are much slower.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
         name="ModelBounds"
         label="Extent to Resample"
         command="SetModelBounds"
         number_of_elements="6"
         default_values="0.0 0.0 0.0 0.0 0.0 0.0">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Set / get the (xmin,xmax, ymin,ymax, zmin,zmax) bounding box in which the sampling is performed. If any of the (min,max) bounds values are min >= max, then the bounds will be computed automatically from the input data. Otherwise, the user-specified bounds will be used.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
         name="Radius"
         label="Gaussian Splat Radius"
         command="SetRadius"
         number_of_elements="1"
         default_values="0.1">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Set / get the radius of propagation of the splat. This value is expressed as a percentage of the length of the longest side of the sampling volume. Smaller numbers greatly reduce execution time.
       </Documentation>
     </DoubleVectorProperty>

     <DoubleVectorProperty
         name="ExponentFactor"
         label="Gaussian Exponent Factor"
         command="SetExponentFactor"
         number_of_elements="1"
         default_values="-5.0">
       <DoubleRangeDomain name="range" max="0.0"/>
       <Documentation>
         Set / get the sharpness of decay of the splats. This is the exponent constant in the Gaussian equation. Normally this is a negative value.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
         name="ScalarWarping"
         label="Scale Splats"
         command="SetScalarWarping"
         number_of_elements="1"
         default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Turn on/off the scaling of splats by scalar value.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
         name="ScaleFactor"
         label="Scale Factor"
         command="SetScaleFactor"
         number_of_elements="1"
         default_values="1.0">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Multiply Gaussian splat distribution by this value. If ScalarWarping is on, then the Scalar value will be multiplied by the ScaleFactor times the Gaussian function.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
         name="NormalWarping"
         label="Elliptical Splats"
         command="SetNormalWarping"
         number_of_elements="1"
         default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Turn on/off the generation of elliptical splats. If normal warping is on, then the input normals affect the distribution of the splat. This boolean is used in combination with the Eccentricity ivar.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
         name="Eccentricity"
         label="Ellipitical Eccentricity"
         command="SetEccentricity"
         number_of_elements="1"
         default_values="2.5">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Control the shape of elliptical splatting. Eccentricity is the ratio of the major axis (aligned along normal) to the minor (axes) aligned along other two axes. So Eccentricity gt 1 creates needles with the long axis in the direction of the normal; Eccentricity lt 1 creates pancakes perpendicular to the normal vector.
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
         name="Capping"
         label="Fill Volume Boundary"
         command="SetCapping"
         number_of_elements="1"
         default_values="1">
       <BooleanDomain name="bool" />
       <Documentation>
         Turn on/off the capping of the outer boundary of the volume to a specified cap value. This can be used to close surfaces (after iso-surfacing) and create other effects.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
         name="CapValue"
         label="Fill Value"
         command="SetCapValue"
         number_of_elements="1"
         default_values="0.0">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Specify the cap value to use. (This instance variable only has effect if the ivar Capping is on.)
       </Documentation>
     </DoubleVectorProperty>

     <IntVectorProperty
         name="Accumulation Mode"
         label="Splat Accumulation Mode"
         command="SetAccumulationMode"
         number_of_elements="1"
         default_values="1">
       <EnumerationDomain name="enum">
         <Entry value="0" text="Min"/>
         <Entry value="1" text="Max"/>
         <Entry value="2" text="Sum"/>
       </EnumerationDomain>
       <Documentation>
         Specify the scalar accumulation mode. This mode expresses how scalar values are combined when splats are overlapped. The Max mode acts like a set union operation and is the most commonly used; the Min mode acts like a set intersection, and the sum is just weird.
       </Documentation>
     </IntVectorProperty>

     <DoubleVectorProperty
         name="NullValue"
         label="Empty Cell Value"
         command="SetNullValue"
         number_of_elements="1"
         default_values="0.0">
       <DoubleRangeDomain name="range" />
       <Documentation>
         Set the Null value for output points not receiving a contribution from the input points. (This is the initial value of the voxel samples.)
       </Documentation>
     </DoubleVectorProperty>
     <!-- End of GaussianSplatter -->
   </SourceProxy>

  </ProxyGroup>
</ServerManagerConfiguration>
