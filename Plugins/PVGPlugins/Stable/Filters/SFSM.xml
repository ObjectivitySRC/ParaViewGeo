<ServerManagerConfiguration>
  <ProxyGroup name="filters">
                
    <!-- Apply Schedule -->
    <SourceProxy name="Apply Schedule" class="vtkApplySchedule">    
    <InputProperty
     name="Input"
     command="SetInputConnection">
      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>
      <DataTypeDomain name="input_type">
        <DataType value="vtkDataSet"/>
      </DataTypeDomain>

      <InputArrayDomain name="input_array" number_of_components="1">
        <RequiredProperties>
          <Property name="SelectInputScalars"
                    function="FieldDataSelection"/>
        </RequiredProperties>
      </InputArrayDomain>

    </InputProperty>

    <StringVectorProperty
        name ="fileName"
        command="SetfileName"
        number_of_elements ="1"
        default_values="">
    </StringVectorProperty>

    <StringVectorProperty
       name ="ArraySelection"
       command="SetArraySelection"
      repeat_command="1"
      number_of_elements_per_command="4"
      element_types="2 0 0 0"
      immediate_update="1">
    </StringVectorProperty>

    <IntVectorProperty name="dateFormat_0"
     command="SetdateFormat_0"
     number_of_elements="1"
     default_values="1">
      <EnumerationDomain name="enum">
        <Entry value="1" text="Day"/>
        <Entry value="30" text="Month"/>
        <Entry value="365" text="Year"/>
      </EnumerationDomain>
    </IntVectorProperty>

    <IntVectorProperty name="dateFormat_1"
     command="SetdateFormat_1"
     number_of_elements="1"
     default_values="1">
      <EnumerationDomain name="enum">
        <Entry value="1" text="Day"/>
        <Entry value="30" text="Month"/>
        <Entry value="365" text="Year"/>
      </EnumerationDomain>
    </IntVectorProperty>

    <IntVectorProperty name="dateFormat_2"
     command="SetdateFormat_2"
     number_of_elements="1"
     default_values="1">
      <EnumerationDomain name="enum">
        <Entry value="1" text="Day"/>
        <Entry value="30" text="Month"/>
        <Entry value="365" text="Year"/>
      </EnumerationDomain>
    </IntVectorProperty>

      <IntVectorProperty name="DateType"
       command="SetDateType"
       number_of_elements="1"
       default_values="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="MSDate"/>
          <Entry value="1" text="Julian"/>
          <Entry value="2" text="ModifiedJulian"/>
          <Entry value="3" text="Matlab"/>
        </EnumerationDomain>
      </IntVectorProperty>      

    <StringVectorProperty name="ScheduleSegName"
     command="SetScheduleSegName"
      number_of_elements="1">
    </StringVectorProperty>

    <StringVectorProperty name="DurationPropertyName"
     command="SetDurationPropertyName"
     number_of_elements="1">
    </StringVectorProperty>

    <StringVectorProperty
        name="SegmentID"
        command="SetSegmentID"
        number_of_elements="1"
        animateable="0"
        label="Segment ID">
      <ArrayListDomain name="array_list"
                       attribute_type="Scalars"
                      input_domain_name="input_array">
        <RequiredProperties>
          <Property name="Input" function="Input"/>
        </RequiredProperties>
      </ArrayListDomain>
      <Documentation>
        This property indicates the name of the segment id property in the input data.
      </Documentation>
    </StringVectorProperty>

      <IntVectorProperty name="durationUnits"
       command="SetdurationUnits"
       number_of_elements="1"
       default_values="1">
        <EnumerationDomain name="enum">
          <Entry value="1" text="Day"/>
          <Entry value="30" text="Month"/>
          <Entry value="365" text="Year"/>
          <Entry value="-24" text="Hour"/>
          <Entry value="-1140" text="Minute"/>
          <Entry value="-86400" text="Second"/>
        </EnumerationDomain>
      </IntVectorProperty>
      
    </SourceProxy>

    <!-- Bounding Box -->
    <SourceProxy name="Bounding Box" class="vtkBBox">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      <DoubleVectorProperty
            name="deltaX"
            command="SetdeltaX"
            number_of_elements="1"
            default_values="100">
        <IntRangeDomain name="range" min="0.0" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaY"
            command="SetdeltaY"
            number_of_elements="1"
            default_values="100">
        <IntRangeDomain name="range" min="0.0" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaZ"
            command="SetdeltaZ"
            number_of_elements="1"
            default_values="100">
        <IntRangeDomain name="range" min="0.0" />
      </DoubleVectorProperty>

      <Hints>
        <Visibility replace_input="3" />
      </Hints>
    </SourceProxy>
  
  <!-- Clean Cells -->  
    <SourceProxy name="Clean Cells" class="vtkCleanCells">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty
         name="PieceInvariant"
         command="SetPieceInvariant"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, the whole data set will be processed at once so that cleaning the data set always produces the same results. If it is set to 0, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory; however the results are not guaranteed to be the same as they would be if the Piece invariant option was on. Setting this option to 0 may produce seams in the output dataset when ParaView is run in parallel.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="Tolerance"
         command="SetTolerance"
         number_of_elements="1"
         animateable="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          If merging nearby points (see PointMerging property) and not using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging as a fraction of the length of the diagonal of the bounding box of the input data set.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="AbsoluteTolerance"
         command="SetAbsoluteTolerance"
         number_of_elements="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          If merging nearby points (see PointMerging property) and using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging in the spatial units of the input data set.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="ToleranceIsAbsolute"
         command="SetToleranceIsAbsolute"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          This property determines whether to use absolute or relative (a percentage of the bounding box) tolerance when performing point merging.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertLinesToPoints"
         command="SetConvertLinesToPoints"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate lines (a "line" whose endpoints are at the same spatial location) will be converted to points.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertPolysToLines"
         command="SetConvertPolysToLines"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate polygons (a "polygon" with only two distinct point coordinates) will be converted to lines.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertStripsToPolys"
         command="SetConvertStripsToPolys"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate triangle strips (a triangle "strip" containing only one triangle) will be converted to triangles.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="PointMerging"
         command="SetPointMerging"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, then points will be merged if they are within the specified Tolerance or AbsoluteTolerance (see the Tolerance and AbsoluteTolerance propertys), depending on the value of the ToleranceIsAbsolute property. (See the ToleranceIsAbsolute property.) If this property is set to 0, points will not be merged.
        </Documentation>
      </IntVectorProperty>


    </SourceProxy>

  <!-- Compute Volumes -->  
    <SourceProxy name="Compute Volumes" class="vtkComputeVolumes">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid"/>
        </DataTypeDomain>

        <InputArrayDomain name="input_array1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                      function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
      </InputProperty>

      <StringVectorProperty
      name="RegionArray"
      command="SetRegionArray"
      number_of_elements="1"
      animateable="0"
      label="Region Array">
        <ArrayListDomain name="array_list"
												 attribute_type="Scalars"
												input_domain_name="input_array1">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property indicates the name of the segment id array.
        </Documentation>
      </StringVectorProperty>

      <StringVectorProperty
         name="VolumesArray"
         command="GetVolumesArray"
         information_only="1">
        <SimpleStringInformationHelper/>
      </StringVectorProperty>

    </SourceProxy>
	
   <!-- ConvertPointsToBlocks -->  
    <SourceProxy name="ConvertPointsToBlocks" class="vtkConvertPointsToBlocks">

      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
		
		<InputArrayDomain name="input_array1" number_of_components="1">
        <RequiredProperties>
          <Property name="SelectInputScalars"
              function="FieldDataSelection"/>
        </RequiredProperties>
		</InputArrayDomain>
	  
		<InputArrayDomain name="input_array2" number_of_components="1">
			<RequiredProperties>
				<Property name="SelectInputScalars"
				function="FieldDataSelection"/>
			</RequiredProperties>
		</InputArrayDomain>
	  
		<InputArrayDomain name="input_array3" number_of_components="1">
			<RequiredProperties>
				<Property name="SelectInputScalars"
				function="FieldDataSelection"/>
			</RequiredProperties>
		</InputArrayDomain>	  
	  </InputProperty>
	  
	  <IntVectorProperty name="UseSizes"
       command="SetUseSizes"
       number_of_elements="1"
       animateable="1"
       default_values="1">
        <BooleanDomain name="bool"/>
        <Documentation>
          Set this propertie if you want to use specific size of each block
        </Documentation>        
      </IntVectorProperty>
	  
	  <StringVectorProperty
        name="XINC"
        command="SetXINC"
	      number_of_elements="1"
	      animateable="0"
		  default_values=""
	      label="XINC">
        <ArrayListDomain name="array_list"
             attribute_type="Scalars"
			 input_domain_name="input_array1">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
		<Documentation>
          This property indicates the name of X block dimension array
        </Documentation>
      </StringVectorProperty>
	  
	  <StringVectorProperty
        name="YINC"
        command="SetYINC"
	      number_of_elements="1"
	      animateable="0"
		  default_values=""
	      label="YINC">
        <ArrayListDomain name="array_list"
             attribute_type="Scalars"
			 input_domain_name="input_array2">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
		<Documentation>
          This property indicates the name of Y block dimension array
        </Documentation>
      </StringVectorProperty>
	  
	 <StringVectorProperty
        name="ZINC"
        command="SetZINC"
	      number_of_elements="1"
	      animateable="0"
		  default_values=""
	      label="ZINC">
        <ArrayListDomain name="array_list"
             attribute_type="Scalars"
			 input_domain_name="input_array3">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
		<Documentation>
          This property indicates the name of Z block dimension array
        </Documentation>
      </StringVectorProperty>
	  
      <DoubleVectorProperty
        name="SizeCX"
        command="SetSizeCX"
        number_of_elements="1"
        animateable="1"
        default_values="5" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          The dimension Size by X Direction
        </Documentation>
      </DoubleVectorProperty>
	  
	  <DoubleVectorProperty
        name="SizeCY"
        command="SetSizeCY"
        number_of_elements="1"
        animateable="1"
        default_values="5" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          The dimension Size by Y Direction
        </Documentation>
      </DoubleVectorProperty>
	  
	  <DoubleVectorProperty
        name="SizeCZ"
        command="SetSizeCZ"
        number_of_elements="1"
        animateable="1"
        default_values="5" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          The dimension Size by Z Direction
        </Documentation>
      </DoubleVectorProperty>      
    </SourceProxy>

  <!-- Extract Unstructered Grid -->  
    <SourceProxy name="ExtractUnstrucGrid" class="vtkExtractUnstrucGrid"
       label="Extract UnstructuredGrid">
      <Documentation
         long_help="This filter extracts a range of blocks from a multiblock dataset."
         short_help="Extract level.">
        This filter extracts a range of groups from a multiblock dataset
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet"/>
        </DataTypeDomain>
        <DataTypeDomain name="output_type">
          <DataType value="vtkUnstructuredGrid"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input to the Extract Group filter.
        </Documentation>
      </InputProperty>

      <IntVectorProperty
         name="BlockIndices"
         command="AddIndex"
         clean_command="RemoveAllIndices"
         repeat_command="1"
         number_of_elements_per_command="1">
        <CompositeTreeDomain name="tree" mode="all">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>
          This property lists the ids of the blocks to extract
          from the input multiblock dataset.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PruneOutput"
         command="SetPruneOutput"
         number_of_elements="1"
         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          When set, the output mutliblock dataset will be pruned to remove empty
          nodes. On by default.
        </Documentation>
      </IntVectorProperty>

      <!-- End ExtractBlock -->
    </SourceProxy>  
  
  <!-- ExtractPolyData -->  
    <SourceProxy name="ExtractPolyData" class="vtkExtractPolyData"
       label="Extract PolyData">
      <Documentation
         long_help="This filter extracts a range of blocks from a multiblock dataset."
         short_help="Extract level.">
        This filter extracts a range of groups from a multiblock dataset
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet"/>
        </DataTypeDomain>
        <DataTypeDomain name="output_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input to the Extract Group filter.
        </Documentation>
      </InputProperty>

      <IntVectorProperty
         name="BlockIndices"
         command="AddIndex"
         clean_command="RemoveAllIndices"
         repeat_command="1"
         number_of_elements_per_command="1">
        <CompositeTreeDomain name="tree" mode="all">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>
          This property lists the ids of the blocks to extract
          from the input multiblock dataset.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PruneOutput"
         command="SetPruneOutput"
         number_of_elements="1"
         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          When set, the output mutliblock dataset will be pruned to remove empty
          nodes. On by default.
        </Documentation>
      </IntVectorProperty>

      <!-- End ExtractBlock -->
    </SourceProxy>

    <!-- InsideClosedSurface -->
    <SourceProxy name="InsideClosedSurface" class="vtkInsideClosedSurface">
      <InputProperty
        name="Source"
        command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolySet"/>
        </DataTypeDomain>
      </InputProperty>
      <InputProperty name="Input"
   command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
    </SourceProxy>
    <!-- End InsideClosedSurface -->
    
    <!-- Intersect Wireframe -->
    <SourceProxy name="Intersect Wireframe" class="vtkIntersectFilter">
      <InputProperty
       name="Source"
       command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>

      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty
      name="Type Points"
      command="SetTypeOfPoints"
      number_of_elements="1"
      default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="Inside Points"/>
          <Entry value="1" text="Outside Points"/>
        </EnumerationDomain>
        <Documentation>
          Inside Points show you the points of the grid inside the defined wireframe
          Outside Points show you the points of the grid outside the defined wireframe
        </Documentation>
      </IntVectorProperty>

    </SourceProxy>

     <!-- Map Attributes -->
    <SourceProxy name="Map Attributes" class="vtkMapAttributes">
      <InputProperty
        name="Source"
        command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                      function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
        <Documentation>
          This property specifies the input to the Threshold filter.
        </Documentation>
      </InputProperty>
      <StringVectorProperty
         name="SelectInputScalars"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Scalars">
        <ArrayListDomain name="array_list"
                         attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>
          The value of this property contains the name of the scalar array from which to perform an operation on.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty
      name="XCubes"
      command="SetXCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
      <IntVectorProperty
      name="YCubes"
      command="SetYCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
      <IntVectorProperty
      name="ZCubes"
      command="SetZCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
    </SourceProxy>

    <!-- Map Attributes To Grid -->
    <SourceProxy name="Map Attributes To Grid" class="vtkMapAttributesToGrid">
      <InputProperty
        name="Source"
        command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                      function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
        <Documentation>
          This property specifies the input to the Threshold filter.
        </Documentation>
      </InputProperty>
      <StringVectorProperty
         name="SelectInputScalars"
         command="SetInputArrayToProcess"
         number_of_elements="5"
         element_types="0 0 0 0 2"
         label="Scalars">
        <ArrayListDomain name="array_list"
                         attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>
          The value of this property contains the name of the scalar array from which to perform an operation on.
        </Documentation>
      </StringVectorProperty>
    </SourceProxy>

    <!-- Map Attributes From Grid -->
    <SourceProxy name="Map Attributes From Grid" class="vtkMapAttributesFromGrid">
      <InputProperty
        name="Source"
        command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <!--<DataType value="vtkImageData"/>
          <DataType value="vtkRectilinearGrid"/>
          <DataType value="vtkStructuredPoints"/>
          <DataType value="vtkStructuredGrid"/>-->
        </DataTypeDomain>
        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                      function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
      </InputProperty>
      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Scalars">
        <ArrayListDomain name="array_list"
                         attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
      </StringVectorProperty>
    </SourceProxy>
  
    <!-- Delaunay 2D-->
    <SourceProxy name="Delaunay 2D" class="vtkMDelaunay2D">
      <Documentation
        long_help="Create 2D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
         short_help="Create 2D Delaunay triangulation of input points.">
        Delaunay2D is a filter that constructs a 2D Delaunay triangulation from a list of input points. These points may be represented by any dataset of type vtkPointSet and subclasses. The output of the filter is a polygonal dataset containing a triangle mesh.

        The 2D Delaunay triangulation is defined as the triangulation that satisfies the Delaunay criterion for n-dimensional simplexes (in this case n=2 and the simplexes are triangles). This criterion states that a circumsphere of each simplex in a triangulation contains only the n+1 defining points of the simplex. In two dimensions, this translates into an optimal triangulation. That is, the maximum interior angle of any triangle is less than or equal to that of any possible triangulation.

        Delaunay triangulations are used to build topological structures from unorganized (or unstructured) points. The input points can be on arbitrary axes (when Best-Fitting option is selected). If they are not on the X-Y plane, the points are translated into the X-Y axes, a surface is created, and they are translated back.

        The Delaunay triangulation can be numerically sensitive in some cases. To prevent problems, try to avoid injecting points that will result in triangles with bad aspect ratios (1000:1 or greater). In practice this means inserting points that are "widely dispersed", and enables smooth transition of triangle sizes throughout the mesh. (You may even want to add extra points to create a better point distribution.) If numerical problems are present, you will see a warning message to this effect at the end of the triangulation process.

        Warning:
        Points arranged on a regular lattice (termed degenerate cases) can be triangulated in more than one way (at least according to the Delaunay criterion). The choice of triangulation (as implemented by this algorithm) depends on the order of the input points. The first three points will form a triangle; other degenerate points will not break this triangle.

        Points that are coincident (or nearly so) may be discarded by the algorithm. This is because the Delaunay triangulation requires unique input points. The output of the Delaunay triangulation is supposedly a convex hull. In certain cases this implementation may not generate the convex hull.
      </Documentation>
      <InputProperty
           name="Input"
           command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input dataset to the Delaunay 2D filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty
        name="ProjectionPlaneMode"
        command="SetProjectionPlaneMode"
        number_of_elements="1"
        default_values="0">
        <EnumerationDomain name="enum">
          <Entry value="0" text="XY Plane"/>
          <Entry value="3" text="YZ Plane"/>
          <Entry value="4" text="XZ Plane"/>
          <Entry value="2" text="Best-Fitting Plane"/>
        </EnumerationDomain>
        <Documentation>
          This property determines type of projection plane to use in performing the triangulation.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty name="Alpha"
       command="SetAlpha"
       number_of_elements="1"
       animateable="1"
       default_values="0.0">
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          The value of this property controls the output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.
        </Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.00001">
        <DoubleRangeDomain name="range" min="0" max="1.0" />
        <Documentation>
          This property specifies a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.
        </Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty name="Offset"
       command="SetOffset"
       number_of_elements="1"
       animateable="1"
       default_values="1.0">
        <DoubleRangeDomain name="range" min="0.75"/>
        <Documentation>
          This property is a multiplier to control the size of the initial, bounding Delaunay triangulation.
        </Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty name="BoundingTriangulation"
       command="SetBoundingTriangulation"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, bounding triangulation points (and associated triangles) are included in the output. These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.
        </Documentation>
      </IntVectorProperty>
    </SourceProxy>

    <!-- PolyStruct -->
    <SourceProxy name="PolyStruct" class="vtkPolyStruct"
     label="Polygon To Grid">
      <Documentation
         long_help="This filter generates a bounding box representation of the input."
         short_help="Generates a bounding box.">
        The Outline filter generates an axis-aligned bounding box for the input dataset. This filter operates on any type of dataset and produces polygonal output.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty
      name="XCubes"
      command="SetXCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
      <IntVectorProperty
      name="YCubes"
      command="SetYCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
      <IntVectorProperty
      name="ZCubes"
      command="SetZCubes"
      number_of_elements="1"
      default_values="10.0">
        <IntRangeDomain name="range" min="2" />
      </IntVectorProperty>
    </SourceProxy>

    <!-- Proximity Threshold -->
    <SourceProxy name="Proximity Threshold" class="vtkProximityThreshold">
      <InputProperty
        name="Source"
        command="SetSourceConnection" >
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      <DoubleVectorProperty
       name="Distance"
       command="SetDistance"
       number_of_elements="1"
       default_values="-1">
      </DoubleVectorProperty>
      <IntVectorProperty
        name="Invert"
        command="SetInvert"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>
      <IntVectorProperty
       name="AllScalars"
       command="SetAllScalars"
       number_of_elements="1"
       default_values="1">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

    </SourceProxy>

    <!-- Radial Distance -->
    <!--<SourceProxy name="Radial Distance" class="vtkRadialDistance">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>
      <DoubleVectorProperty
       name="Measurement Point"
       command="SetMeasurePoint"
       number_of_elements="3"
       default_values="0 0 0">
      </DoubleVectorProperty>

      <IntVectorProperty
       name="Step Number"
       command="SetStepNumber"
       number_of_elements="1"
       default_values="1">
        <IntRangeDomain name="range" min="1" max="100"/>
      </IntVectorProperty>
    </SourceProxy>-->
    
    <SourceProxy name="Radial Distance" class="vtkRadialDistance">            
      <InputProperty
        name="Input"
        command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkDataSet"/>
           </DataTypeDomain>                            
      </InputProperty>
      <DoubleVectorProperty
         name="MeasurePoint"
         command="SetMeasurePoint"
         number_of_elements="3"
         animateable="1"
         default_values="0.0 0.0 0.0">
         <DoubleRangeDomain name="range"/>
      </DoubleVectorProperty>
        
      <IntVectorProperty
         name="Step Number"
         command="SetStepNumber"
         number_of_elements="1"
         default_values="1">
         <IntRangeDomain name="range" min="1" max="100"/>
      </IntVectorProperty>
            
      <Hints>
        <PropertyGroup type="PointSource" >
          <Property function="WorldPosition"  name="MeasurePoint" />
        </PropertyGroup>
      </Hints>
    </SourceProxy>
    
    <SourceProxy name="RegexThreshold" class="vtkRegexThreshold">
      <InputProperty name="Input"
		    command="SetInputConnection">
	<ProxyGroupDomain name="groups">
	  <Group name="sources"/>
	  <Group name="filters"/>
	</ProxyGroupDomain>
	<DataTypeDomain name="input_type">
	  <DataType value="vtkDataSet"/>
	</DataTypeDomain>
	<InputArrayDomain name="input_array" number_of_components="1">
	  <RequiredProperties>
	    <Property name="SelectInputScalars" 
		      function="FieldDataSelection"/>
	  </RequiredProperties>
	</InputArrayDomain>
      </InputProperty>
      <StringVectorProperty 
        name="SelectInputScalars" 
        command="SetInputArrayToProcess"
	number_of_elements="5"
	element_types="0 0 0 0 2"
	label="Scalars">
	<ArrayListDomain name="array_list" 
			 attribute_type="Scalars">
	  <RequiredProperties>
	    <Property name="Input" function="Input"/>
	  </RequiredProperties>
	</ArrayListDomain>
	<FieldDataDomain name="field_list">
	  <RequiredProperties>
	    <Property name="Input" function="Input"/>
	  </RequiredProperties>
	</FieldDataDomain>
      </StringVectorProperty>
      
      <StringVectorProperty
       name="Regex"
       command="SetRegex"
       number_of_elements="1"
       default_values="Regex">                     
     </StringVectorProperty>
     
      <IntVectorProperty 
        name="AllScalars" 
        command="SetAllScalars" 
        number_of_elements="1"
        default_values="1" > 
       <BooleanDomain name="bool"/>
       <Documentation>
         If the value of this property is 1, then a cell is only included in the output if the value of the selected array for all its points is within the threshold. This is only relevant when thresholding by a point-centered array.
       </Documentation>
     </IntVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   </SourceProxy>

    <!-- RelativeTransform -->
    <SourceProxy name="RelativeTransform" class="vtkRelativeTransform" label="Relative Transform">

      <Documentation
        long_help="Performs a transform on a data set about its centroid instead of (0,0,0)."
        short_help="Performs a transform on a data set about its centroid instead of (0,0,0).">
      </Documentation>

      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
          Something
        </Documentation>
      </InputProperty>

      <DoubleVectorProperty
        name="Trans"
        command="SetTrans"
        number_of_elements="3"
        default_values="0 0 0">
        <Documentation>
          Set the relative translation about centroid in x,y,z.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
            name="Rot"
            command="SetRot"
            number_of_elements="3"
            default_values="0 0 0">
        <Documentation>
          Set the relative rotation about centroid in x,y,z.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
            name="Scale"
            command="SetScale"
            number_of_elements="3"
            default_values="1 1 1">
        <Documentation>
          Set the scale factor in x,y,z.
        </Documentation>
      </DoubleVectorProperty>    

    <DoubleVectorProperty
      name="Origin"
      command="SetOrigin"
      number_of_elements="3"
      default_values="0 0 0">
      <Documentation>
        Set the origin in x,y,z.
      </Documentation>
    </DoubleVectorProperty>
    </SourceProxy>
    
    <!-- Sequence Arrows -->
    <SourceProxy name="Sequence Arrows" class="vtkSequenceArrows">
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars" function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>


      </InputProperty>
      <StringVectorProperty
          name="SelectInputScalars"
          command="SetInputArrayToProcess"
          number_of_elements="5"
          element_types="0 0 0 0 2"
          label="Scalars">
        <ArrayListDomain name="array_list"
                         attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
      </StringVectorProperty>
      <DoubleVectorProperty
      name="Size"
      command="SetSize"
      number_of_elements="1"
      default_values="1.0">
      </DoubleVectorProperty>
    </SourceProxy>

    <!-- Sum Billboard-->
    <SourceProxy name="SumBillboard" class="vtkSumBillboard">
      <InputProperty name="Input"
		    command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>

        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>

        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>

      </InputProperty>
      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
	number_of_elements="5"
	element_types="0 0 0 0 2"
	label="Scalars">
        <ArrayListDomain name="array_list"
             attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
      </StringVectorProperty>

      <StringVectorProperty
         name="Format"
         command="SetFormat"
   number_of_elements="1"
   default_values="Total Value ">
      </StringVectorProperty>

      <Hints>
        <Visibility replace_input="2" />
      </Hints>
    </SourceProxy>


    <!-- SurfaceReconstructor -->
    <SourceProxy name="SurfaceReconstructor" class="vtkSurfaceReconstructor" label="Surface Reconstructor">

      <Documentation
        long_help="takes a list of points assumed to lie on
          the surface of a solid 3D object. A signed measure of the distance to the
          surface is computed and sampled on a regular grid. The grid can then be
          contoured at zero to extract the surface. The default values for
          neighborhood size and sample spacing should give reasonable results for
          most uses but can be set if desired. This procedure is based on the PhD
          work of Hugues Hoppe: http://www.research.microsoft.com/~hoppe"
        short_help="Approximate surface reconstruction from a data set of points.">
      </Documentation>

      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
          Something
        </Documentation>
      </InputProperty>

      <IntVectorProperty
        name="NeighborhoodSize"
        command="SetNeighborhoodSize"
        number_of_elements="1"
        default_values="20">
        <Documentation>
          Specify the number of neighbors each point has,
          used for estimating the local surface orientation.

          The default value of 20 should be OK for most applications,
          higher values can be specified if the spread of points is uneven.

          Values as low as 10 may yield adequate results for some surfaces.

          Higher values cause the algorithm to take longer.

          Higher values will cause errors on sharp boundaries.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="Resolution"
        command="SetResolution"
        number_of_elements="1"
        default_values="1">
        <Documentation>
          Will adjust the spacing of the 3D sampling grid. 1x resolution is a reasonable first guess for most surfaces.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry value="1" text="1x (Try this first with new data sets)" />
          <Entry value="2" text="2x" />
          <Entry value="4" text="4x" />
          <Entry value="8" text="8x" />
          <Entry value="16" text="16x " />
          <Entry value="32" text="32x " />
          <Entry value="64" text="64x " />
        </EnumerationDomain>
      </IntVectorProperty>

    </SourceProxy>
    <!-- Tensor Glyph -->
     <SourceProxy name="Tensor Glyph" class="vtkTensorGlyphFilter">
            
          <InputProperty
              name="Source"
              command="SetSourceConnection" >
            <ProxyGroupDomain name="groups">
              <Group name="sources"/>
              <Group name="filters"/>
            </ProxyGroupDomain>
            <DataTypeDomain name="input_type">
              <DataType value="vtkPolyData"/>
            </DataTypeDomain>
          </InputProperty>
            
          <InputProperty
            name="Input"
            command="SetInputConnection">
               <ProxyGroupDomain name="groups">
                 <Group name="sources"/>
                 <Group name="filters"/>
               </ProxyGroupDomain>
               <DataTypeDomain name="input_type">
                 <DataType value="vtkDataSet"/>
               </DataTypeDomain>                       
          </InputProperty>

          <IntVectorProperty
             name="Scaling"
             command="SetScaling"
             number_of_elements="1"
             default_values="1" >
            <BooleanDomain name="bool"/>
            <Documentation>
              Turn on/off scaling of glyph with eigenvalues
            </Documentation>
          </IntVectorProperty>

          <DoubleVectorProperty name="ScaleFactor"
            command="SetScaleFactor"
            number_of_elements="1"
            animateable="1"
            default_values="0.5">
            <DoubleRangeDomain name="range" min="0"/>
            <Documentation>
              Specify scale factor to scale object by. (Scale factor always affects output even if scaling is off.)
            </Documentation>
          </DoubleVectorProperty>

            <IntVectorProperty
               name="ThreeGlyphs"
               command="SetThreeGlyphs"
               number_of_elements="1"
               default_values="0" >
              <BooleanDomain name="bool"/>
              <Documentation>
                Turn on/off drawing three glyphs
              </Documentation>
            </IntVectorProperty>

            <IntVectorProperty
               name="Symmetric"
               command="SetSymmetric"
               number_of_elements="1"
               default_values="0" >
              <BooleanDomain name="bool"/>
              <Documentation>
                Turn on/off drawing a mirror of each glyph
              </Documentation>
            </IntVectorProperty>

            <DoubleVectorProperty
               name="Length"
               command="SetLength"
               number_of_elements="1"
               animateable="1"
               default_values="0.0" >
              <DoubleRangeDomain name="range" min="0" />
              <Documentation>
                Set the distance, along x, from the origin to the end of the
                source glyph. It is used to draw the symmetric glyphs.
              </Documentation>
            </DoubleVectorProperty>

            <IntVectorProperty
               name="ExtractEigenvalues"
               command="SetExtractEigenvalues"
               number_of_elements="1"
               default_values="1" >
              <BooleanDomain name="bool"/>
              <Documentation>
                Turn on/off extraction of eigenvalues from tensor.
              </Documentation>
            </IntVectorProperty>            
            
            <IntVectorProperty
               name="ColorGlyphs"
               command="SetColorGlyphs"
               number_of_elements="1"
               default_values="1" >
              <BooleanDomain name="bool"/>
              <Documentation>
                Turn on/off coloring of glyph with input scalar data or
                eigenvalues. If false, or input scalar data not present, then the
                scalars from the source object are passed through the filter.
              </Documentation>
            </IntVectorProperty>

            <IntVectorProperty
               name="ColorMode"
               command="SetColorMode"
               number_of_elements="1"
               default_values="0" >              
              <EnumerationDomain name="enum">
                <Entry value="0" text="Color By Scalars"/>
                <Entry value="1" text="Color By Eigenvalues"/>
              </EnumerationDomain>              
              <Documentation>
                Set the color mode to be used for the glyphs.  This can be set to
                use the input scalars (default) or to use the eigenvalues at the
                point.  If ThreeGlyphs is set and the eigenvalues are chosen for
                coloring then each glyph is colored by the corresponding
                eigenvalue and if not set the color corresponding to the largest
                eigenvalue is chosen.
              </Documentation>
            </IntVectorProperty>

            <IntVectorProperty
               name="EigenvaluesProduct"
               command="SetEigenvaluesProduct"
               number_of_elements="1"
               default_values="1" >
              <BooleanDomain name="bool"/>
              <Documentation>
                if COLOR_BY_EIGENVALUES is active, setting this value to 1
                will allow coloring by eigenvalues product instead
                of maximum eigenvalue. if COLOR_BY_EIGENVALUES is not used
                this property has no effect
              </Documentation>
            </IntVectorProperty>            
            
            <IntVectorProperty
               name="ClampScaling"
               command="SetClampScaling"
               number_of_elements="1"
               default_values="1" >
              <BooleanDomain name="bool"/>
              <Documentation>
                 Turn on/off scalar clamping. If scalar clamping is on, the ivar
                 MaxScaleFactor is used to control the maximum scale factor. (This is
                 useful to prevent uncontrolled scaling near singularities.)
              </Documentation>
            </IntVectorProperty>


            <DoubleVectorProperty name="MaxScaleFactor"
              command="SetMaxScaleFactor"
              number_of_elements="1"
              animateable="1"
              default_values="0.5">
              <DoubleRangeDomain name="range" min="0"/>
              <Documentation>
                Set/Get the maximum allowable scale factor. This value is compared to the
                combination of the scale factor times the eigenvalue. If less, the scale
                factor is reset to the MaxScaleFactor. The boolean ClampScaling has to
                be "on" for this to work.
              </Documentation>
            </DoubleVectorProperty>            
            
          </SourceProxy>

    <!-- Volumique Tetrahedralization -->
    <SourceProxy name="Volumique Tetrahedralization" class="vtkTetgen">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>

        <InputArrayDomain name="input_array1"
                          optional="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                      function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
      </InputProperty>

      <IntVectorProperty
        name="tetgenCommand"
        command="SettetgenCommand"
        number_of_elements="1"
        default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="Select a Tetrahedralization Command"/>
          <Entry value="1" text="Constrained Delaunay tetrahedralization(CDT)"/>
          <Entry value="2" text="CDT without adding points " />
          <Entry value="3" text="Quality mesh generation"/>
          <Entry value="4" text="Imposes volume constraints" />
          <Entry value="5" text="Quality mesh and volume constraints" />
        </EnumerationDomain>
      </IntVectorProperty>

      <DoubleVectorProperty
            name="RadiusEdgeRatio"
            command="SetRadiusEdgeRatio"
            number_of_elements="1"
            default_values="2.0">
        <DoubleRangeDomain name="range" min="0.61" />
        <Documentation>
          A tetrahedron t has a
          unique circumsphere. Let R = R(t) be that radius and L = L(t) the length
          of the shortest edge. The radius-edge ratio Q = Q(t) of the tetrahedron is:
          Q = R/L.
          This ratio is minimized by the regular tetrahedron (in which case the lengths
          of the six edges are equal, and the circumcenter is the barycenter), that is:
          Q >= 0.612
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
            name="MaxTetrahedronVolume"
            command="SetMaxTetrahedronVolume"
            number_of_elements="1"
            default_values="1000000">
        <IntRangeDomain name="range" min="0.0" />
        <Documentation>
          no tetrahedra is generated whose volume is larger
          than that number
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
            name="MaxTetrahedronVolumeInBox"
            command="SetMaxTetrahedronVolumeInBox"
            number_of_elements="1"
            default_values="1000000">
        <IntRangeDomain name="range" min="0.0" />
        <Documentation>
          no tetrahedra is generated whose volume is larger
          than that number
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
            name="MaxTetrahedronVolumeInBox2"
            command="SetMaxTetrahedronVolumeInBox2"
            number_of_elements="1"
            default_values="1000000">
        <IntRangeDomain name="range" min="0.0" />
        <Documentation>
          no tetrahedra is generated whose volume is larger
          than that number
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="WithRegions"
       command="SetWithRegions"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <IntVectorProperty name="WithPredefinedRegions"
       command="SetWithPredefinedRegions"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <IntVectorProperty name="WithBoundingBox"
       command="SetWithBoundingBox"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <DoubleVectorProperty
            name="deltaX"
            command="SetdeltaX"
            number_of_elements="1"
            default_values="150">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaY"
            command="SetdeltaY"
            number_of_elements="1"
            default_values="150">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaZ"
            command="SetdeltaZ"
            number_of_elements="1"
            default_values="150">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>

      <IntVectorProperty name="WithBBX1"
       command="SetWithBBX1"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <IntVectorProperty name="WithBBX2"
       command="SetWithBBX2"
       number_of_elements="1"
       animateable="1"
       default_values="0">
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <DoubleVectorProperty
            name="deltaX2"
            command="SetdeltaX2"
            number_of_elements="1"
            default_values="200">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaY2"
            command="SetdeltaY2"
            number_of_elements="1"
            default_values="200">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>
      <DoubleVectorProperty
            name="deltaZ2"
            command="SetdeltaZ2"
            number_of_elements="1"
            default_values="200">
        <IntRangeDomain name="range" min="101" />
      </DoubleVectorProperty>

      <StringVectorProperty
      name="RegionArray"
      command="SetRegionArray"
      number_of_elements="1"
      animateable="0"
      label="Region Array">
        <ArrayListDomain name="array_list"
												 attribute_type="Scalars"
												input_domain_name="input_array1">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property indicates the name of the segment id array.
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty
         name="PieceInvariant"
         command="SetPieceInvariant"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, the whole data set will be processed at once so that cleaning the data set always produces the same results. If it is set to 0, the data set can be processed one piece at a time, so it is not necessary for the entire data set to fit into memory; however the results are not guaranteed to be the same as they would be if the Piece invariant option was on. Setting this option to 0 may produce seams in the output dataset when ParaView is run in parallel.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty
         name="Tolerance"
         command="SetTolerance"
         number_of_elements="1"
         animateable="1"
         default_values="0.0" >
        <DoubleRangeDomain name="range" min="0" max="1" />
        <Documentation>
          If merging nearby points (see PointMerging property) and not using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging as a fraction of the length of the diagonal of the bounding box of the input data set.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="AbsoluteTolerance"
         command="SetAbsoluteTolerance"
         number_of_elements="1"
         default_values="0" >
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          If merging nearby points (see PointMerging property) and using absolute tolerance (see ToleranceIsAbsolute property), this property specifies the tolerance for performing merging in the spatial units of the input data set.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
         name="ToleranceIsAbsolute"
         command="SetToleranceIsAbsolute"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          This property determines whether to use absolute or relative (a percentage of the bounding box) tolerance when performing point merging.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertLinesToPoints"
         command="SetConvertLinesToPoints"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate lines (a "line" whose endpoints are at the same spatial location) will be converted to points.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertPolysToLines"
         command="SetConvertPolysToLines"
         number_of_elements="1"
         default_values="0" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate polygons (a "polygon" with only two distinct point coordinates) will be converted to lines.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="ConvertStripsToPolys"
         command="SetConvertStripsToPolys"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, degenerate triangle strips (a triangle "strip" containing only one triangle) will be converted to triangles.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
         name="PointMerging"
         command="SetPointMerging"
         number_of_elements="1"
         default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, then points will be merged if they are within the specified Tolerance or AbsoluteTolerance (see the Tolerance and AbsoluteTolerance propertys), depending on the value of the ToleranceIsAbsolute property. (See the ToleranceIsAbsolute property.) If this property is set to 0, points will not be merged.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
            name="numberOfTetrahedronInfo"
            command="GetnumberOfTetrahedron"
            number_of_elements="1"
            information_only="1"
            default_values="0">
        <SimpleIntInformationHelper/>
      </IntVectorProperty>

    </SourceProxy>

    <!-- Time Billboard -->
    <SourceProxy name="TimeBillboard" class="vtkTimeBillboard">
      <InputProperty name="Input"
		    command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>

        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>

        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars"
                function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>

      </InputProperty>
      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
	number_of_elements="5"
	element_types="0 0 0 0 2"
	label="Scalars">
        <ArrayListDomain name="array_list"
             attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
      </StringVectorProperty>


      <IntVectorProperty
        name="TimeFormat"
        command="SetTimeFormat"
        number_of_elements="1"
        default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="MSDate"/>
          <Entry value="1" text="Julian"/>
          <Entry value="2" text="ModifiedJulian"/>
          <Entry value="3" text="Matlab"/>
        </EnumerationDomain>
      </IntVectorProperty>

      <StringVectorProperty
         name="Format"
         command="SetFormat"
   number_of_elements="1"
   default_values="%Y-%m-%dT%H:%M:%S">
      </StringVectorProperty>

      <StringVectorProperty
        name="Text"
        command="SetText"
	number_of_elements="1"
	default_values="The Start and End Time's are: ">
      </StringVectorProperty>

      <Hints>
        <Visibility replace_input="2" />
      </Hints>
    </SourceProxy>
    
    <!-- TimeThreshold -->
    <SourceProxy name="TimeThreshold" class="vtkTimeThreshold">

      <InputProperty name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" number_of_components="1">
          <RequiredProperties>
            <Property name="SelectInputScalars" function="FieldDataSelection"/>
          </RequiredProperties>
        </InputArrayDomain>
      </InputProperty>

      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
	      number_of_elements="5"
	      element_types="0 0 0 0 2"
	      label="Scalars">
        <ArrayListDomain name="array_list"
			    attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <FieldDataDomain name="field_list">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </FieldDataDomain>
      </StringVectorProperty>

      <IntVectorProperty
        name="TimeFormat"
        command="SetTimeFormat"
        number_of_elements="1"
        default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="MSDate"/>
          <Entry value="1" text="Julian"/>
          <Entry value="2" text="ModifiedJulian"/>
          <Entry value="3" text="Matlab"/>
        </EnumerationDomain>
      </IntVectorProperty>

      <StringVectorProperty
        name="UpperDate"
        command="SetUpperChar"
	      number_of_elements="1"
	      default_values="2008-01-01T00:00:00">
      </StringVectorProperty>

      <StringVectorProperty
        name="LowerDate"
        command="SetLowerChar"
	      number_of_elements="1"
	      default_values="1985-01-01T12:00:00">
      </StringVectorProperty>

      <IntVectorProperty
        name="AllScalars"
        command="SetAllScalars"
        number_of_elements="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If the value of this property is 1, then a cell is only included in the output if the value of the selected array for all its points is within the threshold. This is only relevant when thresholding by a point-centered array.
        </Documentation>
      </IntVectorProperty>

      <Hints>
        <Visibility replace_input="2" />
      </Hints>
    </SourceProxy>

    <!-- Top Of Cell -->
    <SourceProxy name="Top Of Cell" class="vtkTopOfCell">
      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>


      <IntVectorProperty
        name="TopOfCellType"
        command="SetTopOfCellType"
        number_of_elements="1"
        default_values="0" >
        <EnumerationDomain name="enum">
          <Entry value="0" text="Xmax"/>
          <Entry value="1" text="Xmin"/>
          <Entry value="2" text="Ymax" />
          <Entry value="3" text="Ymin" />
          <Entry value="4" text="Zmax" />
          <Entry value="5" text="Zmin" />

        </EnumerationDomain>

      </IntVectorProperty>
    </SourceProxy>
    <SourceProxy name="Delaunay3D" class="vtkDelaunay3D" label="Delaunay 3D">
      <Documentation
         long_help="Create 3D Delaunay triangulation of input points. 
It expects a vtkPointSet as input and produces vtkPolyData as output. 
The points are expected to be in a mostly planar distribution."
         short_help="Create 3D Delaunay triangulation of input points.">
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input dataset to the Delaunay 2D filter.
        </Documentation>
      </InputProperty>
      <DoubleVectorProperty name="Alpha"
        command="SetAlpha"
        number_of_elements="1"
        animateable="1"
        default_values="0.0">
        <DoubleRangeDomain name="range" min="0"/>
        <Documentation>
          The value of this property controls the output of this filter. For a non-zero alpha value, only edges or triangles contained within a sphere centered at mesh vertices will be output. Otherwise, only triangles will be output.
        </Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        animateable="1"
        default_values="0.00001">
        <DoubleRangeDomain name="range" min="0" max="1.0" />
        <Documentation>
          This property specifies a tolerance to control discarding of closely spaced points. This tolerance is specified as a fraction of the diagonal length of the bounding box of the points.
        </Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty name="Offset"
        command="SetOffset"
        number_of_elements="1"
        animateable="1"
        default_values="1.0">
        <DoubleRangeDomain name="range" min="0.75"/>
        <Documentation>
          This property is a multiplier to control the size of the initial, bounding Delaunay triangulation.
        </Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty name="BoundingTriangulation"
        command="SetBoundingTriangulation"
        number_of_elements="1"
        animateable="1"
        default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is set to 1, bounding triangulation points (and associated triangles) are included in the output. These are introduced as an initial triangulation to begin the triangulation process. This feature is nice for debugging output.
        </Documentation>
      </IntVectorProperty>
    </SourceProxy>    
  </ProxyGroup>



  <ProxyGroup name="sources">
    <SourceProxy name="DiskSource" class="vtkDiskSource" label="Disk Source">

      <DoubleVectorProperty name="Outer Radius"
        command="SetOuterRadius"
        number_of_elements="1"
        animateable="1"
        default_values="2">
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Inner Radius"
        command="SetInnerRadius"
        number_of_elements="1"
        animateable="1"
        default_values="1">
      </DoubleVectorProperty>

      <IntVectorProperty name="Radial Resolution"
        command="SetRadialResolution"
        number_of_elements="1"
        animateable="1"
        default_values="10">
      </IntVectorProperty>

      <IntVectorProperty name="Circumferential Resolution"
        command="SetCircumferentialResolution"
        number_of_elements="1"
        animateable="1"
        default_values="10">
      </IntVectorProperty>
    </SourceProxy>
  </ProxyGroup>

  <ProxyGroup name="filters">
    <!-- Poly Line Add Points -->
    <SourceProxy name="Add Points" class="vtkPolyLineAddPoints">
    <InputProperty
         name="Input"
         command="SetInputConnection">
           <ProxyGroupDomain name="groups">
             <Group name="sources"/>
             <Group name="filters"/>
           </ProxyGroupDomain>
           <DataTypeDomain name="input_type">
             <DataType value="vtkPolyData"/>
           </DataTypeDomain>
           <Documentation>
             This property specifies the input dataset to the PolyLineAddPoints filter.
           </Documentation>
      </InputProperty>
      
      <IntVectorProperty
        name="Multiply Factor"
        command="SetAddFactor"
        number_of_elements="1"
        animateable="1"
        default_values="2" >
       <IntRangeDomain name="range" min="2" max="10" />
       <Documentation>
         Factor to multiply the number of points by
       </Documentation>
     </IntVectorProperty>
    </SourceProxy>
    <!-- End Poly Line Add Points -->
    
    
    <!-- Annotate Volume -->
    <!--SourceProxy name="Annotate Volume" class="vtkAnnotation">
      <InputProperty name="Input"
		    command="SetInputConnection">
      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>
      <DataTypeDomain name="input_type">
        <DataType value="vtkDataSet"/>
      </DataTypeDomain>
      </InputProperty>      
      <StringVectorProperty
        name="Format"
        command="SetFormat"
        number_of_elements="1"
        default_values="Volume for object">     
      </StringVectorProperty>
     <Hints>
       <Visibility replace_input="2" />
     </Hints>
   </SourceProxy-->
   <!-- End Annotate Volume -->
	 
	 <SourceProxy name="Ruler" class="vtkRuler">

      <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData"/>
        </DataTypeDomain>
      </InputProperty>      
      
      <DoubleVectorProperty
         name="Point1"
         command="SetPoint1"
         number_of_elements="3"
         animateable="1"
         default_values="-0.5 0.0 0.0" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          This property controls the coordinates of the first endpoint of the line.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty
         name="Point2"
         command="SetPoint2"
         number_of_elements="3"
         animateable="1"
         default_values="0.5 0.0 0.0" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          This property controls the coordinates of the second endpoint of the line.
        </Documentation>
      </DoubleVectorProperty>

      <Hints>
        <PropertyGroup type="LineSource" label="Line">
          <Property function="Point1WorldPosition" name="Point1" />
          <Property function="Point2WorldPosition" name="Point2" />
        </PropertyGroup>
      </Hints>

      <DoubleVectorProperty
       name="distance"
       command="Getdistance"
       number_of_elements="1"
       information_only="1"
       default_values="-1.0">
        <SimpleDoubleInformationHelper/>
      </DoubleVectorProperty>

      <DoubleVectorProperty
       name="xDistance"
       command="GetxDistance"
       number_of_elements="1"
       information_only="1"
       default_values="-1.0">
        <SimpleDoubleInformationHelper/>
      </DoubleVectorProperty>

      <DoubleVectorProperty
       name="yDistance"
       command="GetyDistance"
       number_of_elements="1"
       information_only="1"
       default_values="-1.0">
        <SimpleDoubleInformationHelper/>
      </DoubleVectorProperty>

      <DoubleVectorProperty
       name="zDistance"
       command="GetzDistance"
       number_of_elements="1"
       information_only="1"
       default_values="-1.0">
        <SimpleDoubleInformationHelper/>
      </DoubleVectorProperty>
			
    </SourceProxy>
    
  </ProxyGroup>
  
</ServerManagerConfiguration>
